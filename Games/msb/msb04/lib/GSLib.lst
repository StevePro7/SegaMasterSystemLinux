                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.1.0 #12072 (MINGW64)
                                      4 ;--------------------------------------------------------
                                      5 	.module GSLib
                                      6 	.optsdcc -mz80
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _GSL_LUTRowUpdate
                                     12 	.globl _GSL_LUTColumnUpdate
                                     13 	.globl _GSL_RAM
                                     14 	.globl _GSL_positionWindow
                                     15 	.globl _GSL_metatileLookup
                                     16 	.globl _GSL_tileLookup
                                     17 	.globl _GSL_refreshVDP
                                     18 	.globl _GSL_scroll
                                     19 	.globl _GSL_VBlank
                                     20 	.globl _GSL_metatileUpdate
                                     21 	.globl _GSL_metatileUpdateCustom
                                     22 	.globl _GSL_getMapWidthInPixels
                                     23 	.globl _GSL_getMapHeightInPixels
                                     24 	.globl _GSL_getMapWidthInMetatiles
                                     25 	.globl _GSL_getMapHeightInMetatiles
                                     26 	.globl _GSL_getScrolltableSize
                                     27 	.globl _GSL_getCurrentX
                                     28 	.globl _GSL_getCurrentY
                                     29 	.globl _GSL_getCollisionCount
                                     30 	.globl _GSL_getScrolltableAddress
                                     31 	.globl _GSL_initializeMap
                                     32 ;--------------------------------------------------------
                                     33 ; special function registers
                                     34 ;--------------------------------------------------------
                                     35 ;--------------------------------------------------------
                                     36 ; ram data
                                     37 ;--------------------------------------------------------
                                     38 	.area _DATA
                           000000    39 G$GSL_RAM$0_0$0==.
      000000                         40 _GSL_RAM::
      000000                         41 	.ds 263
                                     42 ;--------------------------------------------------------
                                     43 ; ram data
                                     44 ;--------------------------------------------------------
                                     45 	.area _INITIALIZED
                                     46 ;--------------------------------------------------------
                                     47 ; absolute external ram data
                                     48 ;--------------------------------------------------------
                                     49 	.area _DABS (ABS)
                                     50 ;--------------------------------------------------------
                                     51 ; global & static initialisations
                                     52 ;--------------------------------------------------------
                                     53 	.area _HOME
                                     54 	.area _GSINIT
                                     55 	.area _GSFINAL
                                     56 	.area _GSINIT
                                     57 ;--------------------------------------------------------
                                     58 ; Home
                                     59 ;--------------------------------------------------------
                                     60 	.area _HOME
                                     61 	.area _HOME
                                     62 ;--------------------------------------------------------
                                     63 ; code
                                     64 ;--------------------------------------------------------
                                     65 	.area _CODE
                           000000    66 	G$GSL_positionWindow$0$0	= .
                                     67 	.globl	G$GSL_positionWindow$0$0
                           000000    68 	C$GSLib.c$56$0_0$8	= .
                                     69 	.globl	C$GSLib.c$56$0_0$8
                                     70 ;GSLib.c:56: void GSL_positionWindow(unsigned int X, unsigned int Y)
                                     71 ;	---------------------------------
                                     72 ; Function GSL_positionWindow
                                     73 ; ---------------------------------
      000000                         74 _GSL_positionWindow::
                           000000    75 	C$GSLib.c$68$1_0$8	= .
                                     76 	.globl	C$GSLib.c$68$1_0$8
                                     77 ;GSLib.c:68: __endasm;
      000000 D1               [10]   78 	pop	de
      000001 E1               [10]   79 	pop	hl
      000002 C1               [10]   80 	pop	bc
      000003 C5               [11]   81 	push	bc
      000004 E5               [11]   82 	push	hl
      000005 D5               [11]   83 	push	de
      000006 CDrB8r00         [17]   84 	call	GSL_PositionWindow
                           000009    85 	C$GSLib.c$69$1_0$8	= .
                                     86 	.globl	C$GSLib.c$69$1_0$8
                                     87 ;GSLib.c:69: }							
                           000009    88 	C$GSLib.c$69$1_0$8	= .
                                     89 	.globl	C$GSLib.c$69$1_0$8
                           000009    90 	XG$GSL_positionWindow$0$0	= .
                                     91 	.globl	XG$GSL_positionWindow$0$0
      000009 C9               [10]   92 	ret
                           00000A    93 	G$GSL_metatileLookup$0$0	= .
                                     94 	.globl	G$GSL_metatileLookup$0$0
                           00000A    95 	C$GSLib.c$73$1_0$10	= .
                                     96 	.globl	C$GSLib.c$73$1_0$10
                                     97 ;GSLib.c:73: unsigned int * GSL_metatileLookup(unsigned int x, unsigned int y)
                                     98 ;	---------------------------------
                                     99 ; Function GSL_metatileLookup
                                    100 ; ---------------------------------
      00000A                        101 _GSL_metatileLookup::
                           00000A   102 	C$GSLib.c$84$1_0$10	= .
                                    103 	.globl	C$GSLib.c$84$1_0$10
                                    104 ;GSLib.c:84: __endasm;
      00000A D1               [10]  105 	pop	de
      00000B E1               [10]  106 	pop	hl
      00000C C1               [10]  107 	pop	bc
      00000D C5               [11]  108 	push	bc
      00000E E5               [11]  109 	push	hl
      00000F D5               [11]  110 	push	de
      000010 CDr0Fr01         [17]  111 	call	GSL_MetatileLookup
                           000013   112 	C$GSLib.c$85$1_0$10	= .
                                    113 	.globl	C$GSLib.c$85$1_0$10
                                    114 ;GSLib.c:85: }
                           000013   115 	C$GSLib.c$85$1_0$10	= .
                                    116 	.globl	C$GSLib.c$85$1_0$10
                           000013   117 	XG$GSL_metatileLookup$0$0	= .
                                    118 	.globl	XG$GSL_metatileLookup$0$0
      000013 C9               [10]  119 	ret
                           000014   120 	G$GSL_tileLookup$0$0	= .
                                    121 	.globl	G$GSL_tileLookup$0$0
                           000014   122 	C$GSLib.c$89$1_0$12	= .
                                    123 	.globl	C$GSLib.c$89$1_0$12
                                    124 ;GSLib.c:89: void GSL_tileLookup(unsigned int x, unsigned int y)
                                    125 ;	---------------------------------
                                    126 ; Function GSL_tileLookup
                                    127 ; ---------------------------------
      000014                        128 _GSL_tileLookup::
                           000014   129 	C$GSLib.c$101$1_0$12	= .
                                    130 	.globl	C$GSLib.c$101$1_0$12
                                    131 ;GSLib.c:101: __endasm;
      000014 D1               [10]  132 	pop	de
      000015 E1               [10]  133 	pop	hl
      000016 C1               [10]  134 	pop	bc
      000017 C5               [11]  135 	push	bc
      000018 E5               [11]  136 	push	hl
      000019 D5               [11]  137 	push	de
      00001A CDr53r01         [17]  138 	call	GSL_TileLookup
                           00001D   139 	C$GSLib.c$102$1_0$12	= .
                                    140 	.globl	C$GSLib.c$102$1_0$12
                                    141 ;GSLib.c:102: }
                           00001D   142 	C$GSLib.c$102$1_0$12	= .
                                    143 	.globl	C$GSLib.c$102$1_0$12
                           00001D   144 	XG$GSL_tileLookup$0$0	= .
                                    145 	.globl	XG$GSL_tileLookup$0$0
      00001D C9               [10]  146 	ret
                           00001E   147 	G$GSL_refreshVDP$0$0	= .
                                    148 	.globl	G$GSL_refreshVDP$0$0
                           00001E   149 	C$GSLib.c$106$1_0$13	= .
                                    150 	.globl	C$GSLib.c$106$1_0$13
                                    151 ;GSLib.c:106: void GSL_refreshVDP()
                                    152 ;	---------------------------------
                                    153 ; Function GSL_refreshVDP
                                    154 ; ---------------------------------
      00001E                        155 _GSL_refreshVDP::
                           00001E   156 	C$GSLib.c$112$1_0$13	= .
                                    157 	.globl	C$GSLib.c$112$1_0$13
                                    158 ;GSLib.c:112: __endasm;
      00001E FD E5            [15]  159 	push	iy
      000020 CDr78r01         [17]  160 	call	GSL_refreshVDP
      000023 FD E1            [14]  161 	pop	iy
                           000025   162 	C$GSLib.c$113$1_0$13	= .
                                    163 	.globl	C$GSLib.c$113$1_0$13
                                    164 ;GSLib.c:113: }
                           000025   165 	C$GSLib.c$113$1_0$13	= .
                                    166 	.globl	C$GSLib.c$113$1_0$13
                           000025   167 	XG$GSL_refreshVDP$0$0	= .
                                    168 	.globl	XG$GSL_refreshVDP$0$0
      000025 C9               [10]  169 	ret
                           000026   170 	G$GSL_scroll$0$0	= .
                                    171 	.globl	G$GSL_scroll$0$0
                           000026   172 	C$GSLib.c$117$1_0$15	= .
                                    173 	.globl	C$GSLib.c$117$1_0$15
                                    174 ;GSLib.c:117: void GSL_scroll(char x, char y)
                                    175 ;	---------------------------------
                                    176 ; Function GSL_scroll
                                    177 ; ---------------------------------
      000026                        178 _GSL_scroll::
                           000026   179 	C$GSLib.c$135$1_0$15	= .
                                    180 	.globl	C$GSLib.c$135$1_0$15
                                    181 ;GSLib.c:135: __endasm;
      000026 C1               [10]  182 	pop	bc
      000027 E1               [10]  183 	pop	hl
      000028 E5               [11]  184 	push	hl
      000029 C5               [11]  185 	push	bc
      00002A FD E5            [15]  186 	push	iy
      00002C 7C               [ 4]  187 	ld	a, h
      00002D 32r22r00         [13]  188 	ld	(# #_GSL_RAM + 34), a
      000030 7D               [ 4]  189 	ld	a, l
      000031 32r21r00         [13]  190 	ld	(# #_GSL_RAM + 33), a
      000034 CDr07r03         [17]  191 	call	GSL_ActiveDisplayRoutine
      000037 FD E1            [14]  192 	pop	iy
                           000039   193 	C$GSLib.c$136$1_0$15	= .
                                    194 	.globl	C$GSLib.c$136$1_0$15
                                    195 ;GSLib.c:136: }
                           000039   196 	C$GSLib.c$136$1_0$15	= .
                                    197 	.globl	C$GSLib.c$136$1_0$15
                           000039   198 	XG$GSL_scroll$0$0	= .
                                    199 	.globl	XG$GSL_scroll$0$0
      000039 C9               [10]  200 	ret
                           00003A   201 	G$GSL_VBlank$0$0	= .
                                    202 	.globl	G$GSL_VBlank$0$0
                           00003A   203 	C$GSLib.c$140$1_0$16	= .
                                    204 	.globl	C$GSLib.c$140$1_0$16
                                    205 ;GSLib.c:140: void GSL_VBlank()
                                    206 ;	---------------------------------
                                    207 ; Function GSL_VBlank
                                    208 ; ---------------------------------
      00003A                        209 _GSL_VBlank::
                           00003A   210 	C$GSLib.c$146$1_0$16	= .
                                    211 	.globl	C$GSLib.c$146$1_0$16
                                    212 ;GSLib.c:146: __endasm;
      00003A FD E5            [15]  213 	push	iy
      00003C CDrE3r04         [17]  214 	call	GSL_VBlankRoutine
      00003F FD E1            [14]  215 	pop	iy
                           000041   216 	C$GSLib.c$147$1_0$16	= .
                                    217 	.globl	C$GSLib.c$147$1_0$16
                                    218 ;GSLib.c:147: }
                           000041   219 	C$GSLib.c$147$1_0$16	= .
                                    220 	.globl	C$GSLib.c$147$1_0$16
                           000041   221 	XG$GSL_VBlank$0$0	= .
                                    222 	.globl	XG$GSL_VBlank$0$0
      000041 C9               [10]  223 	ret
                           000042   224 	G$GSL_metatileUpdate$0$0	= .
                                    225 	.globl	G$GSL_metatileUpdate$0$0
                           000042   226 	C$GSLib.c$151$1_0$17	= .
                                    227 	.globl	C$GSLib.c$151$1_0$17
                                    228 ;GSLib.c:151: void GSL_metatileUpdate()
                                    229 ;	---------------------------------
                                    230 ; Function GSL_metatileUpdate
                                    231 ; ---------------------------------
      000042                        232 _GSL_metatileUpdate::
                           000042   233 	C$GSLib.c$155$1_0$17	= .
                                    234 	.globl	C$GSLib.c$155$1_0$17
                                    235 ;GSLib.c:155: __endasm;
      000042 CDr44r02         [17]  236 	call	GSL_MetatileUpdate
                           000045   237 	C$GSLib.c$156$1_0$17	= .
                                    238 	.globl	C$GSLib.c$156$1_0$17
                                    239 ;GSLib.c:156: }
                           000045   240 	C$GSLib.c$156$1_0$17	= .
                                    241 	.globl	C$GSLib.c$156$1_0$17
                           000045   242 	XG$GSL_metatileUpdate$0$0	= .
                                    243 	.globl	XG$GSL_metatileUpdate$0$0
      000045 C9               [10]  244 	ret
                           000046   245 	G$GSL_metatileUpdateCustom$0$0	= .
                                    246 	.globl	G$GSL_metatileUpdateCustom$0$0
                           000046   247 	C$GSLib.c$160$1_0$19	= .
                                    248 	.globl	C$GSLib.c$160$1_0$19
                                    249 ;GSLib.c:160: void GSL_metatileUpdateCustom(unsigned int x, unsigned int y, unsigned int offset)
                                    250 ;	---------------------------------
                                    251 ; Function GSL_metatileUpdateCustom
                                    252 ; ---------------------------------
      000046                        253 _GSL_metatileUpdateCustom::
                           000046   254 	C$GSLib.c$178$1_0$19	= .
                                    255 	.globl	C$GSLib.c$178$1_0$19
                                    256 ;GSLib.c:178: __endasm;	
      000046 C1               [10]  257 	pop	bc
      000047 E1               [10]  258 	pop	hl
      000048 22r17r00         [16]  259 	ld	(# #_GSL_RAM + 23), hl
      00004B E1               [10]  260 	pop	hl
      00004C 22r19r00         [16]  261 	ld	(# #_GSL_RAM + 25), hl
      00004F E1               [10]  262 	pop	hl
      000050 ED 5Br0Dr00      [20]  263 	ld	de, (# #_GSL_RAM + 13)
      000054 19               [11]  264 	add	hl, de
      000055 22r15r00         [16]  265 	ld	(# #_GSL_RAM + 21), hl
      000058 E5               [11]  266 	push	hl
      000059 E5               [11]  267 	push	hl
      00005A E5               [11]  268 	push	hl
      00005B C5               [11]  269 	push	bc
      00005C CDr44r02         [17]  270 	call	GSL_MetatileUpdate
                           00005F   271 	C$GSLib.c$179$1_0$19	= .
                                    272 	.globl	C$GSLib.c$179$1_0$19
                                    273 ;GSLib.c:179: }
                           00005F   274 	C$GSLib.c$179$1_0$19	= .
                                    275 	.globl	C$GSLib.c$179$1_0$19
                           00005F   276 	XG$GSL_metatileUpdateCustom$0$0	= .
                                    277 	.globl	XG$GSL_metatileUpdateCustom$0$0
      00005F C9               [10]  278 	ret
                           000060   279 	G$GSL_getMapWidthInPixels$0$0	= .
                                    280 	.globl	G$GSL_getMapWidthInPixels$0$0
                           000060   281 	C$GSLib.c$182$1_0$20	= .
                                    282 	.globl	C$GSLib.c$182$1_0$20
                                    283 ;GSLib.c:182: unsigned int GSL_getMapWidthInPixels()
                                    284 ;	---------------------------------
                                    285 ; Function GSL_getMapWidthInPixels
                                    286 ; ---------------------------------
      000060                        287 _GSL_getMapWidthInPixels::
                           000060   288 	C$GSLib.c$184$1_0$20	= .
                                    289 	.globl	C$GSLib.c$184$1_0$20
                                    290 ;GSLib.c:184: return *((unsigned int*)(&GSL_RAM + 6));
      000060 2Ar06r00         [16]  291 	ld	hl, (#(_GSL_RAM + 0x0006) + 0)
                           000063   292 	C$GSLib.c$185$1_0$20	= .
                                    293 	.globl	C$GSLib.c$185$1_0$20
                                    294 ;GSLib.c:185: }
                           000063   295 	C$GSLib.c$185$1_0$20	= .
                                    296 	.globl	C$GSLib.c$185$1_0$20
                           000063   297 	XG$GSL_getMapWidthInPixels$0$0	= .
                                    298 	.globl	XG$GSL_getMapWidthInPixels$0$0
      000063 C9               [10]  299 	ret
                           000064   300 	G$GSL_getMapHeightInPixels$0$0	= .
                                    301 	.globl	G$GSL_getMapHeightInPixels$0$0
                           000064   302 	C$GSLib.c$189$1_0$21	= .
                                    303 	.globl	C$GSLib.c$189$1_0$21
                                    304 ;GSLib.c:189: unsigned int GSL_getMapHeightInPixels()
                                    305 ;	---------------------------------
                                    306 ; Function GSL_getMapHeightInPixels
                                    307 ; ---------------------------------
      000064                        308 _GSL_getMapHeightInPixels::
                           000064   309 	C$GSLib.c$191$1_0$21	= .
                                    310 	.globl	C$GSLib.c$191$1_0$21
                                    311 ;GSLib.c:191: return *((unsigned int*)(&GSL_RAM + 8));
      000064 2Ar08r00         [16]  312 	ld	hl, (#(_GSL_RAM + 0x0008) + 0)
                           000067   313 	C$GSLib.c$192$1_0$21	= .
                                    314 	.globl	C$GSLib.c$192$1_0$21
                                    315 ;GSLib.c:192: }
                           000067   316 	C$GSLib.c$192$1_0$21	= .
                                    317 	.globl	C$GSLib.c$192$1_0$21
                           000067   318 	XG$GSL_getMapHeightInPixels$0$0	= .
                                    319 	.globl	XG$GSL_getMapHeightInPixels$0$0
      000067 C9               [10]  320 	ret
                           000068   321 	G$GSL_getMapWidthInMetatiles$0$0	= .
                                    322 	.globl	G$GSL_getMapWidthInMetatiles$0$0
                           000068   323 	C$GSLib.c$196$1_0$22	= .
                                    324 	.globl	C$GSLib.c$196$1_0$22
                                    325 ;GSLib.c:196: unsigned int GSL_getMapWidthInMetatiles()
                                    326 ;	---------------------------------
                                    327 ; Function GSL_getMapWidthInMetatiles
                                    328 ; ---------------------------------
      000068                        329 _GSL_getMapWidthInMetatiles::
                           000068   330 	C$GSLib.c$198$1_0$22	= .
                                    331 	.globl	C$GSLib.c$198$1_0$22
                                    332 ;GSLib.c:198: return *((unsigned int*)(&GSL_RAM + 2));
      000068 2Ar02r00         [16]  333 	ld	hl, (#(_GSL_RAM + 0x0002) + 0)
                           00006B   334 	C$GSLib.c$199$1_0$22	= .
                                    335 	.globl	C$GSLib.c$199$1_0$22
                                    336 ;GSLib.c:199: }
                           00006B   337 	C$GSLib.c$199$1_0$22	= .
                                    338 	.globl	C$GSLib.c$199$1_0$22
                           00006B   339 	XG$GSL_getMapWidthInMetatiles$0$0	= .
                                    340 	.globl	XG$GSL_getMapWidthInMetatiles$0$0
      00006B C9               [10]  341 	ret
                           00006C   342 	G$GSL_getMapHeightInMetatiles$0$0	= .
                                    343 	.globl	G$GSL_getMapHeightInMetatiles$0$0
                           00006C   344 	C$GSLib.c$203$1_0$23	= .
                                    345 	.globl	C$GSLib.c$203$1_0$23
                                    346 ;GSLib.c:203: unsigned int GSL_getMapHeightInMetatiles()
                                    347 ;	---------------------------------
                                    348 ; Function GSL_getMapHeightInMetatiles
                                    349 ; ---------------------------------
      00006C                        350 _GSL_getMapHeightInMetatiles::
                           00006C   351 	C$GSLib.c$205$1_0$23	= .
                                    352 	.globl	C$GSLib.c$205$1_0$23
                                    353 ;GSLib.c:205: return *((unsigned int*)(&GSL_RAM + 4));
      00006C 2Ar04r00         [16]  354 	ld	hl, (#(_GSL_RAM + 0x0004) + 0)
                           00006F   355 	C$GSLib.c$206$1_0$23	= .
                                    356 	.globl	C$GSLib.c$206$1_0$23
                                    357 ;GSLib.c:206: }
                           00006F   358 	C$GSLib.c$206$1_0$23	= .
                                    359 	.globl	C$GSLib.c$206$1_0$23
                           00006F   360 	XG$GSL_getMapHeightInMetatiles$0$0	= .
                                    361 	.globl	XG$GSL_getMapHeightInMetatiles$0$0
      00006F C9               [10]  362 	ret
                           000070   363 	G$GSL_getScrolltableSize$0$0	= .
                                    364 	.globl	G$GSL_getScrolltableSize$0$0
                           000070   365 	C$GSLib.c$210$1_0$24	= .
                                    366 	.globl	C$GSLib.c$210$1_0$24
                                    367 ;GSLib.c:210: unsigned int GSL_getScrolltableSize()
                                    368 ;	---------------------------------
                                    369 ; Function GSL_getScrolltableSize
                                    370 ; ---------------------------------
      000070                        371 _GSL_getScrolltableSize::
                           000070   372 	C$GSLib.c$212$1_0$24	= .
                                    373 	.globl	C$GSLib.c$212$1_0$24
                                    374 ;GSLib.c:212: return *((unsigned int*)(&GSL_RAM + 0));
      000070 2Ar00r00         [16]  375 	ld	hl, (#_GSL_RAM + 0)
                           000073   376 	C$GSLib.c$213$1_0$24	= .
                                    377 	.globl	C$GSLib.c$213$1_0$24
                                    378 ;GSLib.c:213: }
                           000073   379 	C$GSLib.c$213$1_0$24	= .
                                    380 	.globl	C$GSLib.c$213$1_0$24
                           000073   381 	XG$GSL_getScrolltableSize$0$0	= .
                                    382 	.globl	XG$GSL_getScrolltableSize$0$0
      000073 C9               [10]  383 	ret
                           000074   384 	G$GSL_getCurrentX$0$0	= .
                                    385 	.globl	G$GSL_getCurrentX$0$0
                           000074   386 	C$GSLib.c$217$1_0$25	= .
                                    387 	.globl	C$GSLib.c$217$1_0$25
                                    388 ;GSLib.c:217: unsigned int GSL_getCurrentX()
                                    389 ;	---------------------------------
                                    390 ; Function GSL_getCurrentX
                                    391 ; ---------------------------------
      000074                        392 _GSL_getCurrentX::
                           000074   393 	C$GSLib.c$219$1_0$25	= .
                                    394 	.globl	C$GSLib.c$219$1_0$25
                                    395 ;GSLib.c:219: return *((unsigned int*)(&GSL_RAM + 27));
      000074 2Ar1Br00         [16]  396 	ld	hl, (#(_GSL_RAM + 0x001b) + 0)
                           000077   397 	C$GSLib.c$220$1_0$25	= .
                                    398 	.globl	C$GSLib.c$220$1_0$25
                                    399 ;GSLib.c:220: }
                           000077   400 	C$GSLib.c$220$1_0$25	= .
                                    401 	.globl	C$GSLib.c$220$1_0$25
                           000077   402 	XG$GSL_getCurrentX$0$0	= .
                                    403 	.globl	XG$GSL_getCurrentX$0$0
      000077 C9               [10]  404 	ret
                           000078   405 	G$GSL_getCurrentY$0$0	= .
                                    406 	.globl	G$GSL_getCurrentY$0$0
                           000078   407 	C$GSLib.c$224$1_0$26	= .
                                    408 	.globl	C$GSLib.c$224$1_0$26
                                    409 ;GSLib.c:224: unsigned int GSL_getCurrentY()
                                    410 ;	---------------------------------
                                    411 ; Function GSL_getCurrentY
                                    412 ; ---------------------------------
      000078                        413 _GSL_getCurrentY::
                           000078   414 	C$GSLib.c$226$1_0$26	= .
                                    415 	.globl	C$GSLib.c$226$1_0$26
                                    416 ;GSLib.c:226: return *((unsigned int*)(&GSL_RAM + 29));
      000078 2Ar1Dr00         [16]  417 	ld	hl, (#(_GSL_RAM + 0x001d) + 0)
                           00007B   418 	C$GSLib.c$227$1_0$26	= .
                                    419 	.globl	C$GSLib.c$227$1_0$26
                                    420 ;GSLib.c:227: }
                           00007B   421 	C$GSLib.c$227$1_0$26	= .
                                    422 	.globl	C$GSLib.c$227$1_0$26
                           00007B   423 	XG$GSL_getCurrentY$0$0	= .
                                    424 	.globl	XG$GSL_getCurrentY$0$0
      00007B C9               [10]  425 	ret
                           00007C   426 	G$GSL_getCollisionCount$0$0	= .
                                    427 	.globl	G$GSL_getCollisionCount$0$0
                           00007C   428 	C$GSLib.c$231$1_0$27	= .
                                    429 	.globl	C$GSLib.c$231$1_0$27
                                    430 ;GSLib.c:231: unsigned char GSL_getCollisionCount()
                                    431 ;	---------------------------------
                                    432 ; Function GSL_getCollisionCount
                                    433 ; ---------------------------------
      00007C                        434 _GSL_getCollisionCount::
                           00007C   435 	C$GSLib.c$233$1_0$27	= .
                                    436 	.globl	C$GSLib.c$233$1_0$27
                                    437 ;GSLib.c:233: return *((unsigned char*)(&GSL_RAM + 44));
      00007C 3Ar2Cr00         [13]  438 	ld	a, (#(_GSL_RAM + 0x002c) + 0)
      00007F 6F               [ 4]  439 	ld	l, a
                           000080   440 	C$GSLib.c$234$1_0$27	= .
                                    441 	.globl	C$GSLib.c$234$1_0$27
                                    442 ;GSLib.c:234: }
                           000080   443 	C$GSLib.c$234$1_0$27	= .
                                    444 	.globl	C$GSLib.c$234$1_0$27
                           000080   445 	XG$GSL_getCollisionCount$0$0	= .
                                    446 	.globl	XG$GSL_getCollisionCount$0$0
      000080 C9               [10]  447 	ret
                           000081   448 	G$GSL_getScrolltableAddress$0$0	= .
                                    449 	.globl	G$GSL_getScrolltableAddress$0$0
                           000081   450 	C$GSLib.c$237$1_0$28	= .
                                    451 	.globl	C$GSLib.c$237$1_0$28
                                    452 ;GSLib.c:237: unsigned char * GSL_getScrolltableAddress()
                                    453 ;	---------------------------------
                                    454 ; Function GSL_getScrolltableAddress
                                    455 ; ---------------------------------
      000081                        456 _GSL_getScrolltableAddress::
                           000081   457 	C$GSLib.c$239$1_0$28	= .
                                    458 	.globl	C$GSLib.c$239$1_0$28
                                    459 ;GSLib.c:239: return *(unsigned char**)(&GSL_RAM + 13);
      000081 2Ar0Dr00         [16]  460 	ld	hl, (#(_GSL_RAM + 0x000d) + 0)
                           000084   461 	C$GSLib.c$240$1_0$28	= .
                                    462 	.globl	C$GSLib.c$240$1_0$28
                                    463 ;GSLib.c:240: }
                           000084   464 	C$GSLib.c$240$1_0$28	= .
                                    465 	.globl	C$GSLib.c$240$1_0$28
                           000084   466 	XG$GSL_getScrolltableAddress$0$0	= .
                                    467 	.globl	XG$GSL_getScrolltableAddress$0$0
      000084 C9               [10]  468 	ret
                           000085   469 	G$GSL_initializeMap$0$0	= .
                                    470 	.globl	G$GSL_initializeMap$0$0
                           000085   471 	C$GSLib.c$244$1_0$30	= .
                                    472 	.globl	C$GSLib.c$244$1_0$30
                                    473 ;GSLib.c:244: void GSL_initializeMap(void *scrolltable, void *metatiles)
                                    474 ;	---------------------------------
                                    475 ; Function GSL_initializeMap
                                    476 ; ---------------------------------
      000085                        477 _GSL_initializeMap::
                           000085   478 	C$GSLib.c$1724$1_0$30	= .
                                    479 	.globl	C$GSLib.c$1724$1_0$30
                                    480 ;GSLib.c:1724: __endasm;
      000085 D1               [10]  481 	pop	de
      000086 E1               [10]  482 	pop	hl
      000087 C1               [10]  483 	pop	bc
      000088 C5               [11]  484 	push	bc
      000089 E5               [11]  485 	push	hl
      00008A D5               [11]  486 	push	de
      00008B CDr91r00         [17]  487 	call	GSL_InitialiseMap
      00008E C3rBEr07         [10]  488 	jp	_Finalise
                                    489 ;	===============================================================================
                                    490 ;	GSLib 1.0 ASM
      000091                        491 	GSL_InitialiseMap:
                                    492 ; == Store MetatileTable Address
      000091 ED 43r13r00      [20]  493 	ld	(# #_GSL_RAM + 19), bc
                                    494 ;	== Store CollisionCount (3rd byte in metatile table)
      000095 03               [ 6]  495 	inc	bc
      000096 03               [ 6]  496 	inc	bc
      000097 03               [ 6]  497 	inc	bc
      000098 0A               [ 7]  498 	ld	a, (bc)
      000099 32r2Cr00         [13]  499 	ld	(# #_GSL_RAM + 44), a
                                    500 ;	== Copy Scrolltable Header to Ram
      00009C 11r00r00         [10]  501 	ld	de, #_GSL_RAM
      00009F 01 0D 00         [10]  502 	ld	bc, #13
      0000A2 ED B0            [21]  503 	ldir
                                    504 ;	== Store # #_GSL_RAM + 13 (ldir will have pushed past header to actual table)
      0000A4 22r0Dr00         [16]  505 	ld	(# #_GSL_RAM + 13), hl
                                    506 ;	== Initialize Ram
      0000A7 21rB7r00         [10]  507 	ld	hl, # #_GSL_RAM + 183
      0000AA 22r2Ar00         [16]  508 	ld	(# #_GSL_RAM + 42), hl
      0000AD AF               [ 4]  509 	xor	a
      0000AE 32r29r00         [13]  510 	ld	(# #_GSL_RAM + 41), a
      0000B1 32r21r00         [13]  511 	ld	(# #_GSL_RAM + 33), a
      0000B4 32r22r00         [13]  512 	ld	(# #_GSL_RAM + 34), a
      0000B7 C9               [10]  513 	ret
      0000B8                        514 	GSL_PositionWindow:
                                    515 ; == Store (x, y) in ram
      0000B8 ED 43r1Dr00      [20]  516 	ld	(# #_GSL_RAM + 29), bc
      0000BC 22r1Br00         [16]  517 	ld	(# #_GSL_RAM + 27), hl
                                    518 ;	**** Calculate and Store # #_GSL_RAM + 15
      0000BF CDr0Fr01         [17]  519 	call	GSL_MetatileLookup
                                    520 ;	== Store # #_GSL_RAM + 15
      0000C2 22r0Fr00         [16]  521 	ld	(# #_GSL_RAM + 15), hl
                                    522 ;	*** Calculate and Store # #_GSL_RAM + 31
                                    523 ;	== Y Modulo 224 (height of window in pixels)
      0000C5 2Ar1Dr00         [16]  524 	ld	hl, (# #_GSL_RAM + 29)
      0000C8 1E E0            [ 7]  525 	ld	e, #224
      0000CA 06 08            [ 7]  526 	ld	b, #8
      0000CC                        527 	_DivLoop:
      0000CC ED 6A            [15]  528 	adc hl, hl
      0000CE 7C               [ 4]  529 	ld	a, h
      0000CF 38 03            [12]  530 	jr	c, _DivCarry1
      0000D1 BB               [ 4]  531 	cp	e
      0000D2 38 03            [12]  532 	jr	c, _DivCarry2
      0000D4                        533 	_DivCarry1:
      0000D4 93               [ 4]  534 	sub e
      0000D5 67               [ 4]  535 	ld	h, a
      0000D6 B7               [ 4]  536 	or	a
      0000D7                        537 	_DivCarry2:
      0000D7 10 F3            [13]  538 	djnz _DivLoop
      0000D9 7D               [ 4]  539 	ld	a, l
      0000DA 17               [ 4]  540 	rla
      0000DB 2F               [ 4]  541 	cpl
                                    542 ;	== Store # #_GSL_RAM + 31
      0000DC 7C               [ 4]  543 	ld	a, h
      0000DD 32r1Fr00         [13]  544 	ld	(# #_GSL_RAM + 31), a
                                    545 ;	*** Calculate and Store # #_GSL_RAM + 17 (top left nametable entry on VDP)
                                    546 ;	== Use Previous Modulo to Calculate Namtable Row Address ((modulo & %11110000) * 4)
      0000E0 3E F8            [ 7]  547 	ld	a, #248
      0000E2 A4               [ 4]  548 	and	h
      0000E3 6F               [ 4]  549 	ld	l, a
      0000E4 AF               [ 4]  550 	xor	a
      0000E5 67               [ 4]  551 	ld	h, a
      0000E6 57               [ 4]  552 	ld	d, a
      0000E7 29               [11]  553 	add	hl, hl
      0000E8 29               [11]  554 	add	hl, hl
      0000E9 29               [11]  555 	add	hl, hl
                                    556 ;	== Add X worth of nametable entries.
                                    557 ;	Divide by 8 then << 1 (below is optimization of this)
      0000EA 3Ar1Br00         [13]  558 	ld	a, (# #_GSL_RAM + 27)
      0000ED E6 F8            [ 7]  559 	and	#248 ; %11111000
      0000EF 1F               [ 4]  560 	rra
      0000F0 1F               [ 4]  561 	rra
      0000F1 5F               [ 4]  562 	ld	e, a
      0000F2 19               [11]  563 	add	hl, de
                                    564 ;	== Add vdp base address of nametable
      0000F3 11 00 78         [10]  565 	ld	de, #0x7800 ; base address of nametable in vram including write bit set (14)
      0000F6 19               [11]  566 	add	hl, de
                                    567 ;	== Store # #_GSL_RAM + 17
      0000F7 23               [ 6]  568 	inc	hl
      0000F8 23               [ 6]  569 	inc	hl
      0000F9 22r11r00         [16]  570 	ld	(# #_GSL_RAM + 17), hl
                                    571 ;	== Set VDP Fine Scroll Values
      0000FC 3Ar1Br00         [13]  572 	ld	a, (# #_GSL_RAM + 27)
      0000FF D3 BF            [11]  573 	out	(#0xBF), a
      000101 3E 88            [ 7]  574 	ld	a, #136 ; $88
      000103 D3 BF            [11]  575 	out	(#0xBF), a
      000105 3Ar1Fr00         [13]  576 	ld	a, (# #_GSL_RAM + 31)
      000108 D3 BF            [11]  577 	out	(#0xBF), a
      00010A 3E 89            [ 7]  578 	ld	a, #137 ; $89
      00010C D3 BF            [11]  579 	out	(#0xBF), a
      00010E C9               [10]  580 	ret
      00010F                        581 	GSL_MetatileLookup:
                                    582 ; == Convert Y to LUT Entry and retrieve value
      00010F 22r17r00         [16]  583 	ld	(# #_GSL_RAM + 23), hl
      000112 ED 43r19r00      [20]  584 	ld	(# #_GSL_RAM + 25), bc
                                    585 ;	== Divide Y by 16 to get Metatile Y Index
      000116 79               [ 4]  586 	ld	a, c
      000117 CB 38            [ 8]  587 	srl	b
      000119 1F               [ 4]  588 	rra
      00011A CB 38            [ 8]  589 	srl	b
      00011C 1F               [ 4]  590 	rra
      00011D CB 38            [ 8]  591 	srl	b
      00011F 1F               [ 4]  592 	rra
      000120 CB 38            [ 8]  593 	srl	b
      000122 1F               [ 4]  594 	rra
      000123 4F               [ 4]  595 	ld	c, a
                                    596 ;	== Multiply Metatile Y Index By Map Metatile Width
      000124 ED 5Br02r00      [20]  597 	ld	de, (# #_GSL_RAM + 2)
      000128 21 00 00         [10]  598 	ld	hl, #0
      00012B 78               [ 4]  599 	ld	a, b
      00012C 06 10            [ 7]  600 	ld	b, #16
      00012E                        601 	_Mult16Loop:
      00012E 29               [11]  602 	add hl, hl
      00012F CB 21            [ 8]  603 	sla	c
      000131 17               [ 4]  604 	rla
      000132 30 01            [12]  605 	jr	nc, _Mult16NoAdd
      000134 19               [11]  606 	add	hl, de
      000135                        607 	_Mult16NoAdd:
      000135 10 F7            [13]  608 	djnz _Mult16Loop
                                    609 ;	== Divide X by 16 to get Metatile X Index and add
      000137 ED 5Br17r00      [20]  610 	ld	de, (# #_GSL_RAM + 23)
      00013B 7B               [ 4]  611 	ld	a, e
      00013C CB 3A            [ 8]  612 	srl	d
      00013E 1F               [ 4]  613 	rra
      00013F CB 3A            [ 8]  614 	srl	d
      000141 1F               [ 4]  615 	rra
      000142 CB 3A            [ 8]  616 	srl	d
      000144 1F               [ 4]  617 	rra
      000145 CB 3A            [ 8]  618 	srl	d
      000147 1F               [ 4]  619 	rra
      000148 5F               [ 4]  620 	ld	e, a
      000149 19               [11]  621 	add	hl, de
                                    622 ;	== Add # #_GSL_RAM + 19 Base Address
      00014A ED 5Br0Dr00      [20]  623 	ld	de, (# #_GSL_RAM + 13)
      00014E 19               [11]  624 	add	hl, de
                                    625 ;	== Put Metatile ID in a and store address in buffer.
      00014F 22r15r00         [16]  626 	ld	(# #_GSL_RAM + 21), hl
      000152 C9               [10]  627 	ret
      000153                        628 	GSL_TileLookup:
                                    629 ; == Create offset for within Metatile (which nametable entry does x,y point to)
      000153 3E 08            [ 7]  630 	ld	a, #8 ; %00001000
      000155 A5               [ 4]  631 	and	l
      000156 1F               [ 4]  632 	rra
      000157 1F               [ 4]  633 	rra
      000158 57               [ 4]  634 	ld	d, a
      000159 3E 08            [ 7]  635 	ld	a, #8 ; %00001000
      00015B A1               [ 4]  636 	and	c
      00015C 1F               [ 4]  637 	rra
      00015D B2               [ 4]  638 	or	d
      00015E F5               [11]  639 	push	af
                                    640 ;	== Retrieve Metatile ID
      00015F CDr0Fr01         [17]  641 	call	GSL_MetatileLookup
                                    642 ;	== Resolve in to Metatile Address - ((ld << 3) + Offset + GSL_METATILE_TABLE)
      000162 7E               [ 7]  643 	ld	a, (hl)
      000163 6F               [ 4]  644 	ld	l, a
      000164 E6 07            [ 7]  645 	and	#7 ; %111
      000166 67               [ 4]  646 	ld	h, a
      000167 7D               [ 4]  647 	ld	a, l
      000168 E6 F8            [ 7]  648 	and	#248 ; %11111000
      00016A 6F               [ 4]  649 	ld	l, a
      00016B F1               [10]  650 	pop	af
      00016C B5               [ 4]  651 	or	l
      00016D 6F               [ 4]  652 	ld	l, a ; hl = pointer to metatile nametable entry we need to write to vdp
      00016E ED 5Br13r00      [20]  653 	ld	de, (# #_GSL_RAM + 19)
      000172 19               [11]  654 	add	hl, de
                                    655 ;	== Get Nametable entry using resolved address
      000173 7E               [ 7]  656 	ld	a, (hl) ; indirection
      000174 23               [ 6]  657 	inc	hl
      000175 66               [ 7]  658 	ld	h, (hl)
      000176 6F               [ 4]  659 	ld	l, a
      000177 C9               [10]  660 	ret
      000178                        661 	GSL_refreshVDP:
                                    662 ; == Set VDP Nametable Pointer
      000178 2Ar11r00         [16]  663 	ld	hl, (# #_GSL_RAM + 17)
      00017B 22r27r00         [16]  664 	ld	(# #_GSL_RAM + 39), hl
                                    665 ;	== Keep a Modified Y to reflect rows being updated
      00017E 2Ar1Dr00         [16]  666 	ld	hl, (# #_GSL_RAM + 29)
      000181 22r20r00         [16]  667 	ld	(# #_GSL_RAM + 32), hl ; using this as temp ram entry
      000184 3Ar1Fr00         [13]  668 	ld	a, (# #_GSL_RAM + 31)
      000187 CB 3F            [ 8]  669 	srl	a
      000189 CB 3F            [ 8]  670 	srl	a
      00018B CB 3F            [ 8]  671 	srl	a
      00018D D6 1C            [ 7]  672 	sub	#28
      00018F 32r2Fr00         [13]  673 	ld	(# #_GSL_RAM + 47), a
      000192 3E 1C            [ 7]  674 	ld	a, #28
      000194 32r30r00         [13]  675 	ld	(# #_GSL_RAM + 47 + 1), a
      000197                        676 	_RefreshLoop:
                                    677 ; == Set VDP Pointer at Start of Row
      000197 2Ar27r00         [16]  678 	ld	hl, (# #_GSL_RAM + 39)
      00019A 0E BF            [ 7]  679 	ld	c, #0xBF
      00019C ED 69            [12]  680 	out	(c), l
      00019E ED 61            [12]  681 	out	(c), h
                                    682 ;	== Lookup Metatile for this Row
      0001A0 ED 4Br20r00      [20]  683 	ld	bc, (# #_GSL_RAM + 32)
      0001A4 2Ar1Br00         [16]  684 	ld	hl, (# #_GSL_RAM + 27)
      0001A7 CDr0Fr01         [17]  685 	call	GSL_MetatileLookup
                                    686 ;	== Store address in iy
      0001AA E5               [11]  687 	push	hl
      0001AB FD E1            [14]  688 	pop	iy
                                    689 ;	== Put Y Offset in to ixl and Unroll a row of Nametable data.
      0001AD 3Ar20r00         [13]  690 	ld	a, (# #_GSL_RAM + 32)
      0001B0 E6 08            [ 7]  691 	and	#8 ; %00001000
      0001B2 0F               [ 4]  692 	rrca
      0001B3 32r2Dr00         [13]  693 	ld	(# #_GSL_RAM + 45), a
      0001B6 CDrA8r02         [17]  694 	call	_unrollRowForNTUpdate ; Unroll buffer table column for nametable updates!
                                    695 ;	== Add Offset to Start location in Buffer.
      0001B9 3Ar1Br00         [13]  696 	ld	a, (# #_GSL_RAM + 27)
      0001BC 0F               [ 4]  697 	rrca
      0001BD 0F               [ 4]  698 	rrca
      0001BE E6 02            [ 7]  699 	and	#2
      0001C0 C6 02            [ 7]  700 	add	a, #2
      0001C2 21r6Fr00         [10]  701 	ld	hl, # #_GSL_RAM + 111
      0001C5 5F               [ 4]  702 	ld	e, a
      0001C6 AF               [ 4]  703 	xor	a
      0001C7 57               [ 4]  704 	ld	d, a
      0001C8 19               [11]  705 	add	hl, de
                                    706 ;	== Calculate Number of Bytes to be Written in first Write, store in b.
      0001C9 3Ar1Br00         [13]  707 	ld	a, (# #_GSL_RAM + 27)
      0001CC C6 08            [ 7]  708 	add	a, #8
      0001CE E6 F8            [ 7]  709 	and	#248 ; %11111000
      0001D0 0F               [ 4]  710 	rrca
      0001D1 0F               [ 4]  711 	rrca
      0001D2 57               [ 4]  712 	ld	d, a
      0001D3 3E 40            [ 7]  713 	ld	a, #64
      0001D5 92               [ 4]  714 	sub	d
      0001D6 E6 3F            [ 7]  715 	and	#63 ; %00111111
      0001D8 57               [ 4]  716 	ld	d, a
                                    717 ;	== Write Buffered Data to VDP Nametable
      0001D9 0E BE            [ 7]  718 	ld	c, #0xBE
      0001DB                        719 	_WriteRow1Loop:
      0001DB ED A3            [16]  720 	outi
      0001DD 15               [ 4]  721 	dec	d
      0001DE C2rDBr01         [10]  722 	jp	nz, _WriteRow1Loop
                                    723 ;	== Set VDP Address to Start of Row for Second Write
      0001E1 ED 5Br27r00      [20]  724 	ld	de, (# #_GSL_RAM + 39)
      0001E5 0E BF            [ 7]  725 	ld	c, #0xBF
      0001E7 3E C0            [ 7]  726 	ld	a, #192 ; %11000000
      0001E9 A3               [ 4]  727 	and	e
      0001EA ED 79            [12]  728 	out	(c), a
      0001EC ED 51            [12]  729 	out	(c), d
                                    730 ;	== Calculate Number of Bytes to be Written in scond Write, store in b.
      0001EE 3Ar1Br00         [13]  731 	ld	a, (# #_GSL_RAM + 27)
      0001F1 C6 08            [ 7]  732 	add	a, #8
      0001F3 E6 F8            [ 7]  733 	and	#248 ; %11111000
      0001F5 0F               [ 4]  734 	rrca
      0001F6 0F               [ 4]  735 	rrca
      0001F7 57               [ 4]  736 	ld	d, a
      0001F8 0E BE            [ 7]  737 	ld	c, #0xBE
                                    738 ;	== Write Buffered Data to VDP Nametable
      0001FA                        739 	_WriteRow2Loop:
      0001FA ED A3            [16]  740 	outi
      0001FC 15               [ 4]  741 	dec	d
      0001FD C2rFAr01         [10]  742 	jp	nz, _WriteRow2Loop
                                    743 ;	**** Prep for Next Write.
                                    744 ;	== Push VDP Nametable address to next Row.
      000200 2Ar27r00         [16]  745 	ld	hl, (# #_GSL_RAM + 39)
      000203 11 40 00         [10]  746 	ld	de, #0x40
      000206 19               [11]  747 	add	hl, de
      000207 22r27r00         [16]  748 	ld	(# #_GSL_RAM + 39), hl
                                    749 ;	== Have we written rows? Return if true;
      00020A 3Ar30r00         [13]  750 	ld	a, (# #_GSL_RAM + 47 + 1)
      00020D 3D               [ 4]  751 	dec	a
      00020E C8               [11]  752 	ret	z
      00020F 32r30r00         [13]  753 	ld	(# #_GSL_RAM + 47 + 1), a
                                    754 ;	== Is next row at top of VDP Nametable, reset Address if true;
      000212 3Ar2Fr00         [13]  755 	ld	a, (# #_GSL_RAM + 47)
      000215 3C               [ 4]  756 	inc	a
      000216 32r2Fr00         [13]  757 	ld	(# #_GSL_RAM + 47), a
      000219 C2r28r02         [10]  758 	jp	nz, _AdjustTempYValue
      00021C 2Ar27r00         [16]  759 	ld	hl, (# #_GSL_RAM + 39)
      00021F 26 78            [ 7]  760 	ld	h, #0x78
      000221 3E 3F            [ 7]  761 	ld	a, #63 ; %00111111
      000223 A5               [ 4]  762 	and	l
      000224 6F               [ 4]  763 	ld	l, a
      000225 22r27r00         [16]  764 	ld	(# #_GSL_RAM + 39), hl
                                    765 ;	== Adjust Temp Y Value for Next Write.
      000228                        766 	_AdjustTempYValue:
      000228 2Ar20r00         [16]  767 	ld hl, (# #_GSL_RAM + 32)
      00022B 16 00            [ 7]  768 	ld	d, #0
      00022D 1E 08            [ 7]  769 	ld	e, #8
      00022F 19               [11]  770 	add	hl, de
      000230 22r20r00         [16]  771 	ld	(# #_GSL_RAM + 32), hl
      000233 C3r97r01         [10]  772 	jp	_RefreshLoop
      000236                        773 	GSL_MetatileUpdateSpecific:
                                    774 ; == Populate Buffered Values with Custom Values.
      000236 22r19r00         [16]  775 	ld	(# #_GSL_RAM + 25), hl
      000239 ED 53r17r00      [20]  776 	ld	(# #_GSL_RAM + 23), de
                                    777 ;	== Add Array offset to Scrolltable bass address then store results.
      00023D 2Ar0Dr00         [16]  778 	ld	hl, (# #_GSL_RAM + 13)
      000240 09               [11]  779 	add	hl, bc
      000241 22r15r00         [16]  780 	ld	(# #_GSL_RAM + 21), hl
                                    781 ;	== Flow to GSL_MetatileUpdate Below
      000244                        782 	GSL_MetatileUpdate:
                                    783 ; == Identify Column of update
      000244 2Ar19r00         [16]  784 	ld	hl, (# #_GSL_RAM + 25)
      000247 1E E0            [ 7]  785 	ld	e, #224
      000249 06 08            [ 7]  786 	ld	b, #8
      00024B                        787 	_MDivLoop:
      00024B ED 6A            [15]  788 	adc hl, hl
      00024D 7C               [ 4]  789 	ld	a, h
      00024E 38 03            [12]  790 	jr	c, _MDivCarry1
      000250 BB               [ 4]  791 	cp	e
      000251 38 03            [12]  792 	jr	c, _MDivCarry2
      000253                        793 	_MDivCarry1:
      000253 93               [ 4]  794 	sub e
      000254 67               [ 4]  795 	ld	h, a
      000255 B7               [ 4]  796 	or	a
      000256                        797 	_MDivCarry2:
      000256 10 F3            [13]  798 	djnz _MDivLoop
      000258 7D               [ 4]  799 	ld	a, l
      000259 17               [ 4]  800 	rla
      00025A 2F               [ 4]  801 	cpl
      00025B 7C               [ 4]  802 	ld	a, h
      00025C 1F               [ 4]  803 	rra
      00025D 1F               [ 4]  804 	rra
      00025E 1F               [ 4]  805 	rra
      00025F 1F               [ 4]  806 	rra
      000260 E6 0F            [ 7]  807 	and	#15
      000262 C6 F0            [ 7]  808 	add	a, #240
      000264 67               [ 4]  809 	ld	h, a
      000265 AF               [ 4]  810 	xor	a
      000266 6F               [ 4]  811 	ld	l, a
      000267 57               [ 4]  812 	ld	d, a ; Prep for X
      000268 CB 3C            [ 8]  813 	srl	h
      00026A CB 1D            [ 8]  814 	rr	l
                                    815 ;	== Isolate metatile location in X and add
      00026C 3Ar17r00         [13]  816 	ld	a, (# #_GSL_RAM + 23)
      00026F E6 F0            [ 7]  817 	and	#240 ; %11110000
      000271 1F               [ 4]  818 	rra
      000272 1F               [ 4]  819 	rra
      000273 5F               [ 4]  820 	ld	e, a
      000274 19               [11]  821 	add	hl, de
                                    822 ;	== Write Resolved Address of Metatile on VDP (including register high bits)
      000275 EB               [ 4]  823 	ex	de, hl
      000276 2Ar2Ar00         [16]  824 	ld	hl, (# #_GSL_RAM + 42)
      000279 73               [ 7]  825 	ld	(hl), e
      00027A 23               [ 6]  826 	inc	hl
      00027B 72               [ 7]  827 	ld	(hl), d
      00027C 23               [ 6]  828 	inc	hl
      00027D EB               [ 4]  829 	ex	de, hl
                                    830 ;	== Resolve Metatile Location from ID
      00027E 2Ar15r00         [16]  831 	ld	hl, (# #_GSL_RAM + 21)
      000281 6E               [ 7]  832 	ld	l, (hl)
      000282 7D               [ 4]  833 	ld	a, l
      000283 E6 07            [ 7]  834 	and	#7 ; %111
                                    835 ;or	#GSL_METATILE_TABLE_HIGH_BYTE ; add high bits of metatile address (table must be on 2k boundary)
      000285 67               [ 4]  836 	ld	h, a
      000286 7D               [ 4]  837 	ld	a, l
      000287 E6 F8            [ 7]  838 	and	#248 ; %11111000
      000289 6F               [ 4]  839 	ld	l, a
      00028A ED 4Br13r00      [20]  840 	ld	bc, (# #_GSL_RAM + 19)
      00028E 09               [11]  841 	add	hl, bc
                                    842 ;	== Copy Contents of Metatile To Ram Buffer
      00028F ED A0            [16]  843 	ldi
      000291 ED A0            [16]  844 	ldi
      000293 ED A0            [16]  845 	ldi
      000295 ED A0            [16]  846 	ldi
      000297 ED A0            [16]  847 	ldi
      000299 ED A0            [16]  848 	ldi
      00029B ED A0            [16]  849 	ldi
      00029D ED A0            [16]  850 	ldi
                                    851 ;	== Update Count and Address for more Metatile Updates if any
      00029F ED 53r2Ar00      [20]  852 	ld	(# #_GSL_RAM + 42), de
      0002A3 21r29r00         [10]  853 	ld	hl, # #_GSL_RAM + 41
      0002A6 34               [11]  854 	inc	(hl)
      0002A7 C9               [10]  855 	ret
      0002A8                        856 	_unrollRowForNTUpdate:
      0002A8 11r6Fr00         [10]  857 	ld de, # #_GSL_RAM + 111
      0002AB 0E 44            [ 7]  858 	ld	c, #17*#4
      0002AD                        859 	_unrollMetaTileRow:
      0002AD FD 6E 00         [19]  860 	ld l, 0 (iy) ; == Resolve metatile address, current metatile pointed to by iy
      0002B0 7D               [ 4]  861 	ld	a, l ; optimized <<3 shift, bits are stored as '43210765' for speed
      0002B1 E6 07            [ 7]  862 	and	#7 ; %111
      0002B3 67               [ 4]  863 	ld	h, a
      0002B4 7D               [ 4]  864 	ld	a, l
      0002B5 E6 F8            [ 7]  865 	and	#248 ; %11111000
      0002B7 6F               [ 4]  866 	ld	l, a
      0002B8 3Ar2Dr00         [13]  867 	ld	a, (# #_GSL_RAM + 45) ; add X offset (in ixl) to get desired column in meta tile.
      0002BB B5               [ 4]  868 	or	l
      0002BC 6F               [ 4]  869 	ld	l, a ; hl = pointer to metatile nametable entry we need to write to vdp
      0002BD C5               [11]  870 	push	bc
      0002BE ED 4Br13r00      [20]  871 	ld	bc, (# #_GSL_RAM + 19)
      0002C2 09               [11]  872 	add	hl, bc
      0002C3 C1               [10]  873 	pop	bc
      0002C4 ED A0            [16]  874 	ldi	; == Write 2x nametable entries to buffer.
      0002C6 ED A0            [16]  875 	ldi	; metatiles are 2 entries wide so l+=2 to move to second entry.
      0002C8 ED A0            [16]  876 	ldi
      0002CA ED A0            [16]  877 	ldi
      0002CC AF               [ 4]  878 	xor	a ; loop
      0002CD B1               [ 4]  879 	or	c
      0002CE C8               [11]  880 	ret	z
      0002CF FD 23            [10]  881 	inc	iy ; Update Scrolltable Pointer
      0002D1 C3rADr02         [10]  882 	jp	_unrollMetaTileRow
      0002D4                        883 	_unrollColumnForNTUpdate:
      0002D4 11r2Fr00         [10]  884 	ld de, # #_GSL_RAM + 47
      0002D7 0E 3C            [ 7]  885 	ld	c, #15*#4
      0002D9                        886 	_unrollMetaTileColumn:
      0002D9 FD 6E 00         [19]  887 	ld l, 0 (iy) ; == Resolve metatile address, current metatile pointed to by iy
      0002DC 7D               [ 4]  888 	ld	a, l ; optimized <<3 shift, bits are stored as '43210765' for speed
      0002DD E6 07            [ 7]  889 	and	#7 ; %111
      0002DF 67               [ 4]  890 	ld	h, a
      0002E0 7D               [ 4]  891 	ld	a, l
      0002E1 E6 F8            [ 7]  892 	and	#248 ; %11111000
      0002E3 6F               [ 4]  893 	ld	l, a
      0002E4 3Ar2Dr00         [13]  894 	ld	a, (# #_GSL_RAM + 45)
      0002E7 B5               [ 4]  895 	or	l
      0002E8 6F               [ 4]  896 	ld	l, a ; hl = pointer to metatile nametable entry we need to write to vdp
      0002E9 C5               [11]  897 	push	bc
      0002EA ED 4Br13r00      [20]  898 	ld	bc, (# #_GSL_RAM + 19)
      0002EE 09               [11]  899 	add	hl, bc
      0002EF C1               [10]  900 	pop	bc
      0002F0 ED A0            [16]  901 	ldi	; == Write 2x nametable entries to buffer.
      0002F2 ED A0            [16]  902 	ldi	; metatiles are 2 entries wide so l+=2 to move to second entry.
      0002F4 23               [ 6]  903 	inc	hl
      0002F5 23               [ 6]  904 	inc	hl
      0002F6 ED A0            [16]  905 	ldi
      0002F8 ED A0            [16]  906 	ldi
      0002FA AF               [ 4]  907 	xor	a ; loop
      0002FB B1               [ 4]  908 	or	c
      0002FC C8               [11]  909 	ret	z
      0002FD 2Ar02r00         [16]  910 	ld	hl, (# #_GSL_RAM + 2) ; Update Scrolltable Pointer
      000300 EB               [ 4]  911 	ex	de, hl
      000301 FD 19            [15]  912 	add	iy, de
      000303 EB               [ 4]  913 	ex	de, hl
      000304 C3rD9r02         [10]  914 	jp	_unrollMetaTileColumn
      000307                        915 	GSL_ActiveDisplayRoutine:
                                    916 ; == Initialize
      000307 FD 21r00r00      [14]  917 	ld	iy, #_GSL_RAM
      00030B AF               [ 4]  918 	xor	a
      00030C 32r23r00         [13]  919 	ld	(# #_GSL_RAM + 35), a
      00030F 32r24r00         [13]  920 	ld	(# #_GSL_RAM + 36), a
      000312                        921 	_xScroll:
                                    922 ; == Check Left / Right Scroll...
      000312 3Ar21r00         [13]  923 	ld	a, (# #_GSL_RAM + 33)
      000315 A7               [ 4]  924 	and	a
      000316 CAr89r03         [10]  925 	jp	z, _yScroll ; no value = no horizontal scroll
      000319 FAr54r03         [10]  926 	jp	m, _leftScroll ; signed = left scroll.
      00031C                        927 	_rightScroll:
                                    928 ; == Update currentXScroll Value.
      00031C 2Ar1Br00         [16]  929 	ld	hl, (# #_GSL_RAM + 27) ; add to current x value
      00031F 45               [ 4]  930 	ld	b, l
      000320 85               [ 4]  931 	add	a, l
      000321 30 01            [12]  932 	jr	nc, _noRightHighByteCarry
      000323 24               [ 4]  933 	inc	h
      000324                        934 	_noRightHighByteCarry:
      000324 6F               [ 4]  935 	ld l, a
      000325 A8               [ 4]  936 	xor	b
      000326 57               [ 4]  937 	ld	d, a ; store low byte different pre / post scroll (for boundary tests)
      000327 22r1Br00         [16]  938 	ld	(# #_GSL_RAM + 27), hl
      00032A                        939 	_rightNametableCheck:
                                    940 ; == Check for NameTable Boundary Cross
      00032A E6 F8            [ 7]  941 	and	#248 ; %11111000
      00032C CAr89r03         [10]  942 	jp	z, _yScroll
                                    943 ;	== NameTable Bounary Crossed... Process
      00032F 3E 01            [ 7]  944 	ld	a, #1
      000331 32r23r00         [13]  945 	ld	(# #_GSL_RAM + 35), a
      000334 3Ar11r00         [13]  946 	ld	a, (# #_GSL_RAM + 17) ; Update NameTable Pointer
      000337 4F               [ 4]  947 	ld	c, a ; (addition bound within low 6 bits!!!)
      000338 E6 C0            [ 7]  948 	and	#192 ; %11000000
      00033A 47               [ 4]  949 	ld	b, a
      00033B 79               [ 4]  950 	ld	a, c
      00033C C6 02            [ 7]  951 	add	a, #2
      00033E E6 3F            [ 7]  952 	and	#63 ; %111111
      000340 B0               [ 4]  953 	or	b
      000341 32r11r00         [13]  954 	ld	(# #_GSL_RAM + 17), a
      000344                        955 	_rightScrolltableCheck:
                                    956 ; == Check for BufferTable Boundary Cross
      000344 7A               [ 4]  957 	ld	a, d
      000345 E6 F0            [ 7]  958 	and	#240 ; %11110000
      000347 CAr89r03         [10]  959 	jp	z, _yScroll
                                    960 ;	== BufferTable Boundary Crossed... Process
      00034A 2Ar0Fr00         [16]  961 	ld	hl, (# #_GSL_RAM + 15) ; Update buffer table pointer.
      00034D 23               [ 6]  962 	inc	hl
      00034E 22r0Fr00         [16]  963 	ld	(# #_GSL_RAM + 15), hl
      000351 C3r89r03         [10]  964 	jp	_yScroll
      000354                        965 	_leftScroll:
                                    966 ; == Update currentXScroll Value.
      000354 2Ar1Br00         [16]  967 	ld	hl, (# #_GSL_RAM + 27) ; add to current x value
      000357 45               [ 4]  968 	ld	b, l
      000358 85               [ 4]  969 	add	a, l
      000359 38 01            [12]  970 	jr	c, _noLeftHighByteCarry
      00035B 25               [ 4]  971 	dec	h
      00035C                        972 	_noLeftHighByteCarry:
      00035C 6F               [ 4]  973 	ld l, a
      00035D A8               [ 4]  974 	xor	b
      00035E 57               [ 4]  975 	ld	d, a ; store low byte different pre / post scroll (for boundary tests)
      00035F 22r1Br00         [16]  976 	ld	(# #_GSL_RAM + 27), hl
      000362                        977 	_leftNametableCheck:
                                    978 ; == Check for NameTable Boundary Cross
      000362 E6 F8            [ 7]  979 	and	#248 ; %11111000
      000364 CAr89r03         [10]  980 	jp	z, _yScroll
                                    981 ;	== NameTable Bounary Crossed... Process
      000367 3E 81            [ 7]  982 	ld	a, #129
      000369 32r23r00         [13]  983 	ld	(# #_GSL_RAM + 35), a
      00036C 3Ar11r00         [13]  984 	ld	a, (# #_GSL_RAM + 17) ; Update name table pointer.
      00036F 4F               [ 4]  985 	ld	c, a ; (subtraction bound within low 6 bits!!!)
      000370 E6 C0            [ 7]  986 	and	#192 ; %11000000
      000372 47               [ 4]  987 	ld	b, a
      000373 79               [ 4]  988 	ld	a, c
      000374 D6 02            [ 7]  989 	sub	#2
      000376 E6 3F            [ 7]  990 	and	#63 ; %111111
      000378 B0               [ 4]  991 	or	b
      000379 32r11r00         [13]  992 	ld	(# #_GSL_RAM + 17), a
      00037C                        993 	_leftScrolltableCheck:
                                    994 ; == Check for BufferTable Boundary Cross
      00037C 7A               [ 4]  995 	ld	a, d
      00037D E6 F0            [ 7]  996 	and	#240 ; %11110000
      00037F CAr89r03         [10]  997 	jp	z, _yScroll
                                    998 ;	== BufferTable Boundary Crossed... Process
      000382 2Ar0Fr00         [16]  999 	ld	hl, (# #_GSL_RAM + 15) ; Update buffer table pointer.
      000385 2B               [ 6] 1000 	dec	hl
      000386 22r0Fr00         [16] 1001 	ld	(# #_GSL_RAM + 15), hl
      000389                       1002 	_yScroll:
                                   1003 ; == Check Up / Down Scroll...
      000389 3Ar22r00         [13] 1004 	ld	a, (# #_GSL_RAM + 34)
      00038C A7               [ 4] 1005 	and	a
      00038D CAr2Fr04         [10] 1006 	jp	z, _processUpdateBuffers ; no value = no vertical scroll
      000390 FArE1r03         [10] 1007 	jp	m, _upScroll ; signed = left scroll.
      000393                       1008 	_downScroll:
                                   1009 ; == Update dummyYScroll Value (wraps around 224 NameTable height!)
      000393 47               [ 4] 1010 	ld	b, a
      000394 3Ar1Fr00         [13] 1011 	ld	a, (# #_GSL_RAM + 31)
      000397 80               [ 4] 1012 	add	a, b
      000398 FE E0            [ 7] 1013 	cp	#224
      00039A DAr9Fr03         [10] 1014 	jp	c, _downNoCrossBoundary
      00039D D6 E0            [ 7] 1015 	sub	#224
      00039F                       1016 	_downNoCrossBoundary:
      00039F 32r1Fr00         [13] 1017 	ld (# #_GSL_RAM + 31), a
      0003A2 78               [ 4] 1018 	ld	a, b
                                   1019 ;	== Update currentYScroll Value.
      0003A3 2Ar1Dr00         [16] 1020 	ld	hl, (# #_GSL_RAM + 29) ; add to current y value
      0003A6 45               [ 4] 1021 	ld	b, l
      0003A7 85               [ 4] 1022 	add	a, l
      0003A8 30 01            [12] 1023 	jr	nc, _noDownHighByteCarry
      0003AA 24               [ 4] 1024 	inc	h
      0003AB                       1025 	_noDownHighByteCarry:
      0003AB 6F               [ 4] 1026 	ld l, a
      0003AC A8               [ 4] 1027 	xor	b
      0003AD 57               [ 4] 1028 	ld	d, a ; store low byte different pre / post scroll (for boundary tests)
      0003AE 22r1Dr00         [16] 1029 	ld	(# #_GSL_RAM + 29), hl
      0003B1                       1030 	_downNametableCheck:
                                   1031 ; == Check for NameTable Boundary Cross
      0003B1 E6 F8            [ 7] 1032 	and	#248 ; %11111000
      0003B3 CAr2Fr04         [10] 1033 	jp	z, _processUpdateBuffers
                                   1034 ;	== NameTable Bounary Crossed... Process
      0003B6 3E 01            [ 7] 1035 	ld	a, #1
      0003B8 32r24r00         [13] 1036 	ld	(# #_GSL_RAM + 36), a
      0003BB 2Ar11r00         [16] 1037 	ld	hl, (# #_GSL_RAM + 17) ; Update name table pointer.
      0003BE 01 40 00         [10] 1038 	ld	bc, #64
      0003C1 09               [11] 1039 	add	hl, bc
      0003C2 3E 7F            [ 7] 1040 	ld	a, #0x7F ; TODO shift this to .defines for variable nat positioning
      0003C4 BC               [ 4] 1041 	cp	h
      0003C5 C2rCAr03         [10] 1042 	jp	nz, _downNoResetNTHighByte
      0003C8 26 78            [ 7] 1043 	ld	h, #0x78
      0003CA                       1044 	_downNoResetNTHighByte:
      0003CA 22r11r00         [16] 1045 	ld (# #_GSL_RAM + 17), hl
      0003CD                       1046 	_downScrolltableCheck:
                                   1047 ; == Check for BufferTable Boundary Cross
      0003CD 7A               [ 4] 1048 	ld	a, d
      0003CE E6 F0            [ 7] 1049 	and	#240 ; %11110000 ; !SMC metatile width bitmask
      0003D0 CAr2Fr04         [10] 1050 	jp	z, _processUpdateBuffers
                                   1051 ;	== BufferTable Boundary Crossed... Process
      0003D3 2Ar0Fr00         [16] 1052 	ld	hl, (# #_GSL_RAM + 15)
      0003D6 ED 4Br02r00      [20] 1053 	ld	bc, (# #_GSL_RAM + 2)
      0003DA 09               [11] 1054 	add	hl, bc
      0003DB 22r0Fr00         [16] 1055 	ld	(# #_GSL_RAM + 15), hl
      0003DE C3r2Fr04         [10] 1056 	jp	_processUpdateBuffers
      0003E1                       1057 	_upScroll:
                                   1058 ; == Update dummyYScroll Value (wraps around 224 NameTable height!)
      0003E1 47               [ 4] 1059 	ld	b, a
      0003E2 3Ar1Fr00         [13] 1060 	ld	a, (# #_GSL_RAM + 31)
      0003E5 80               [ 4] 1061 	add	a, b
      0003E6 DArEBr03         [10] 1062 	jp	c, _upNoCrossBoundary
      0003E9 D6 20            [ 7] 1063 	sub	#32
      0003EB                       1064 	_upNoCrossBoundary:
      0003EB 32r1Fr00         [13] 1065 	ld (# #_GSL_RAM + 31), a
      0003EE 78               [ 4] 1066 	ld	a, b
                                   1067 ;	== Update currentYScroll Value.
      0003EF 2Ar1Dr00         [16] 1068 	ld	hl, (# #_GSL_RAM + 29) ; add to current y value
      0003F2 45               [ 4] 1069 	ld	b, l
      0003F3 85               [ 4] 1070 	add	a, l
      0003F4 38 01            [12] 1071 	jr	c, _noUpHighByteCarry
      0003F6 25               [ 4] 1072 	dec	h
      0003F7                       1073 	_noUpHighByteCarry:
      0003F7 6F               [ 4] 1074 	ld l, a
      0003F8 A8               [ 4] 1075 	xor	b
      0003F9 57               [ 4] 1076 	ld	d, a ; store low byte different pre / post scroll (for boundary tests)
      0003FA 22r1Dr00         [16] 1077 	ld	(# #_GSL_RAM + 29), hl
      0003FD                       1078 	_upNametableCheck:
                                   1079 ; == Check for NameTable Boundary Cross
      0003FD 7A               [ 4] 1080 	ld	a, d
      0003FE E6 F8            [ 7] 1081 	and	#248 ; %11111000
      000400 CAr2Fr04         [10] 1082 	jp	z, _processUpdateBuffers
                                   1083 ;	== NameTable Bounary Crossed... Process
      000403 3E 81            [ 7] 1084 	ld	a, #129
      000405 32r24r00         [13] 1085 	ld	(# #_GSL_RAM + 36), a
      000408 2Ar11r00         [16] 1086 	ld	hl, (# #_GSL_RAM + 17) ; Update name table pointer.
      00040B 01 40 00         [10] 1087 	ld	bc, #64
      00040E B7               [ 4] 1088 	or	a
      00040F ED 42            [15] 1089 	sbc	hl, bc
      000411 3E 77            [ 7] 1090 	ld	a, #0x78 - 1
      000413 BC               [ 4] 1091 	cp	h
      000414 C2r19r04         [10] 1092 	jp	nz, _upNoResetNTHighByte
      000417 26 7E            [ 7] 1093 	ld	h, #0x7F - 1
      000419                       1094 	_upNoResetNTHighByte:
      000419 22r11r00         [16] 1095 	ld (# #_GSL_RAM + 17), hl
      00041C                       1096 	_upScrolltableCheck:
                                   1097 ; == Check for BufferTable Boundary Cross
      00041C 7A               [ 4] 1098 	ld	a, d
      00041D E6 F0            [ 7] 1099 	and	#240 ; %11110000 ; !SMC metatile width bitmask
      00041F CAr2Fr04         [10] 1100 	jp	z, _processUpdateBuffers
                                   1101 ;	== BufferTable Boundary Crossed... Process
      000422 2Ar0Fr00         [16] 1102 	ld	hl, (# #_GSL_RAM + 15)
      000425 ED 4Br02r00      [20] 1103 	ld	bc, (# #_GSL_RAM + 2)
      000429 AF               [ 4] 1104 	xor	a
      00042A ED 42            [15] 1105 	sbc	hl, bc
      00042C 22r0Fr00         [16] 1106 	ld	(# #_GSL_RAM + 15), hl
      00042F                       1107 	_processUpdateBuffers:
      00042F                       1108 	_updateX:
                                   1109 ; == Left / Right Scroll Occur?
      00042F 3Ar23r00         [13] 1110 	ld	a, (# #_GSL_RAM + 35)
      000432 B7               [ 4] 1111 	or	a
      000433 CAr8Ar04         [10] 1112 	jp	z, _updateY
      000436 FAr68r04         [10] 1113 	jp	m, _updateBufferLeft
      000439                       1114 	_updateBufferRight:
                                   1115 ; == Create Adjusted btPointer for _unrollColumnForNTUpdate call
      000439 FD 2Ar0Fr00      [20] 1116 	ld	iy, (# #_GSL_RAM + 15)
      00043D 11 10 00         [10] 1117 	ld	de, #16
      000440 FD 19            [15] 1118 	add	iy, de
                                   1119 ;	== Create X offset for _unrollColumnForNTUpdate call
      000442 3Ar1Br00         [13] 1120 	ld	a, (# #_GSL_RAM + 27) ; get x offset for meta tile. Writing column so need to adjust for this.
      000445 E6 08            [ 7] 1121 	and	#8 ; %00001000
      000447 0F               [ 4] 1122 	rrca
      000448 0F               [ 4] 1123 	rrca
      000449 32r2Dr00         [13] 1124 	ld	(# #_GSL_RAM + 45), a ;ld ixl, a
                                   1125 ;	== Unroll MetaTiles and get NameTable data for update
      00044C CDrD4r02         [17] 1126 	call	_unrollColumnForNTUpdate
                                   1127 ;	== Store Adjusted NameTable Address for Update.
      00044F 3Ar11r00         [13] 1128 	ld	a, (# #_GSL_RAM + 17)
      000452 4F               [ 4] 1129 	ld	c, a
      000453 E6 C0            [ 7] 1130 	and	#192 ; %11000000 ; update name table pointer.
      000455 47               [ 4] 1131 	ld	b, a
      000456 79               [ 4] 1132 	ld	a, c
      000457 D6 02            [ 7] 1133 	sub	#2
      000459 E6 3F            [ 7] 1134 	and	#63 ; %111111
      00045B B0               [ 4] 1135 	or	b
      00045C 32r25r00         [13] 1136 	ld	(# #_GSL_RAM + 37), a
      00045F 3Ar12r00         [13] 1137 	ld	a, (# #_GSL_RAM + 17 + 1)
      000462 32r26r00         [13] 1138 	ld	(# #_GSL_RAM + 37 + 1), a
      000465 C3r8Ar04         [10] 1139 	jp	_updateY
      000468                       1140 	_updateBufferLeft:
                                   1141 ; == NameTable Update Required?
      000468 1F               [ 4] 1142 	rra
      000469 D2r8Ar04         [10] 1143 	jp	nc, _updateY
                                   1144 ;	== Create Adjusted btPointer for _unrollColumnForNTUpdate call
      00046C FD 2Ar0Fr00      [20] 1145 	ld	iy, (# #_GSL_RAM + 15)
      000470 3Ar1Br00         [13] 1146 	ld	a, (# #_GSL_RAM + 27)
      000473 C6 08            [ 7] 1147 	add	a, #8
      000475 E6 08            [ 7] 1148 	and	#8 ; %00001000
      000477 C2r7Cr04         [10] 1149 	jp	nz, _createXOffset
      00047A FD 23            [10] 1150 	inc	iy
                                   1151 ;	== Create X offset for _unrollColumnForNTUpdate call
      00047C                       1152 	_createXOffset:
      00047C 0F               [ 4] 1153 	rrca
      00047D 0F               [ 4] 1154 	rrca
      00047E 32r2Dr00         [13] 1155 	ld	(# #_GSL_RAM + 45), a ;ld ixl, a
                                   1156 ;	== Unroll MetaTiles and get NameTable data for update
      000481 CDrD4r02         [17] 1157 	call	_unrollColumnForNTUpdate
                                   1158 ;	== Store NameTable Address for Update (no adjustment required)
      000484 2Ar11r00         [16] 1159 	ld	hl, (# #_GSL_RAM + 17)
      000487 22r25r00         [16] 1160 	ld	(# #_GSL_RAM + 37), hl
      00048A                       1161 	_updateY:
                                   1162 ; == Left / Right Scroll Occur?
      00048A 3Ar24r00         [13] 1163 	ld	a, (# #_GSL_RAM + 36)
      00048D B7               [ 4] 1164 	or	a
      00048E C8               [11] 1165 	ret	z
      00048F FArCAr04         [10] 1166 	jp	m, _updateBufferUp
      000492                       1167 	_updateBufferDown:
                                   1168 ; == NameTable Update Required?
      000492 1F               [ 4] 1169 	rra
      000493 D0               [11] 1170 	ret	nc
                                   1171 ;	== Create Adjusted btPointer for _unrollColumnForNTUpdate call
      000494 FD 2Ar0Fr00      [20] 1172 	ld	iy, (# #_GSL_RAM + 15)
      000498 ED 5Br0Ar00      [20] 1173 	ld	de, (# #_GSL_RAM + 10)
      00049C FD 19            [15] 1174 	add	iy, de
      00049E ED 5Br02r00      [20] 1175 	ld	de, (# #_GSL_RAM + 2)
      0004A2 3Ar1Dr00         [13] 1176 	ld	a, (# #_GSL_RAM + 29) ; get x offset for meta tile. Writing column so need to adjust for this.
      0004A5 D6 08            [ 7] 1177 	sub	#8
      0004A7 E6 08            [ 7] 1178 	and	#8 ; %00001000
      0004A9 C2rAEr04         [10] 1179 	jp	nz, _createYOffset
      0004AC FD 19            [15] 1180 	add	iy, de
      0004AE                       1181 	_createYOffset:
      0004AE 0F               [ 4] 1182 	rrca
      0004AF 32r2Dr00         [13] 1183 	ld	(# #_GSL_RAM + 45), a ;ld ixl, a
                                   1184 ;	== Unroll MetaTiles and get NameTable data for update
      0004B2 CDrA8r02         [17] 1185 	call	_unrollRowForNTUpdate
                                   1186 ;	== Store Adjusted NameTable Address for Update.
      0004B5 2Ar11r00         [16] 1187 	ld	hl, (# #_GSL_RAM + 17)
      0004B8 11 40 00         [10] 1188 	ld	de, #64
      0004BB B7               [ 4] 1189 	or	a
      0004BC ED 52            [15] 1190 	sbc	hl, de
      0004BE 3E 77            [ 7] 1191 	ld	a, #0x78 - 1
      0004C0 BC               [ 4] 1192 	cp	h
      0004C1 C2rC6r04         [10] 1193 	jp	nz, _noYNametableWrap
      0004C4 26 7E            [ 7] 1194 	ld	h, #0x7F - 1
      0004C6                       1195 	_noYNametableWrap:
      0004C6 22r27r00         [16] 1196 	ld (# #_GSL_RAM + 39), hl
      0004C9 C9               [10] 1197 	ret
      0004CA                       1198 	_updateBufferUp:
                                   1199 ; == NameTable Update Required?
      0004CA 0F               [ 4] 1200 	rrca
      0004CB D0               [11] 1201 	ret	nc
                                   1202 ;	== Get btPointer for _unrollColumnForNTUpdate call
      0004CC FD 2Ar0Fr00      [20] 1203 	ld	iy, (# #_GSL_RAM + 15)
                                   1204 ;	== Create Y offset for _unrollColumnForNTUpdate call
      0004D0 3Ar1Dr00         [13] 1205 	ld	a, (# #_GSL_RAM + 29) ; get x offset for meta tile. Writing column so need to adjust for this.
      0004D3 E6 08            [ 7] 1206 	and	#8 ; %00001000
      0004D5 0F               [ 4] 1207 	rrca
      0004D6 32r2Dr00         [13] 1208 	ld	(# #_GSL_RAM + 45), a ;ld ixl, a
      0004D9 CDrA8r02         [17] 1209 	call	_unrollRowForNTUpdate ; Unroll buffer table column for nametable updates!
                                   1210 ;	== Store NameTable Address for Update (no adjustment required)
      0004DC 2Ar11r00         [16] 1211 	ld	hl, (# #_GSL_RAM + 17)
      0004DF 22r27r00         [16] 1212 	ld	(# #_GSL_RAM + 39), hl
      0004E2 C9               [10] 1213 	ret
      0004E3                       1214 	GSL_VBlankRoutine:
                                   1215 ; == Check if row update required.
      0004E3 3Ar24r00         [13] 1216 	ld	a, (# #_GSL_RAM + 36)
      0004E6 A7               [ 4] 1217 	and	a
      0004E7 CAr46r05         [10] 1218 	jp	z, _updateColumn
      0004EA                       1219 	_writeRow:
                                   1220 ; == Put VDP Pointer Address in Shadow Register and Set VDP Pointer.
      0004EA D9               [ 4] 1221 	exx
      0004EB 2Ar27r00         [16] 1222 	ld	hl, (# #_GSL_RAM + 39)
      0004EE 0E BF            [ 7] 1223 	ld	c, #0xBF
      0004F0 ED 69            [12] 1224 	out	(c), l
      0004F2 ED 61            [12] 1225 	out	(c), h
      0004F4 D9               [ 4] 1226 	exx
      0004F5 0E BE            [ 7] 1227 	ld	c, #0xBE
                                   1228 ;	== Construct LUT address For First Write
      0004F7 3Ar1Br00         [13] 1229 	ld	a, (# #_GSL_RAM + 27)
      0004FA E6 F8            [ 7] 1230 	and	#248 ; %11111000
      0004FC 0F               [ 4] 1231 	rrca
      0004FD 0F               [ 4] 1232 	rrca
      0004FE 21r2Fr08         [10] 1233 	ld	hl, #_GSL_LUTRowUpdate
      000501 85               [ 4] 1234 	add	a, l
      000502 D2r06r05         [10] 1235 	jp	nc, _finaliseLUTRowAddress
      000505 24               [ 4] 1236 	inc	h
      000506                       1237 	_finaliseLUTRowAddress:
      000506 6F               [ 4] 1238 	ld l, a
      000507 E5               [11] 1239 	push	hl ; Story copy on stack
                                   1240 ;	== Extract Jump Location from LUT and store in IY
                                   1241 ;	Jump is for unrolled VDP Write code
      000508 5E               [ 7] 1242 	ld	e, (hl)
      000509 23               [ 6] 1243 	inc	hl
      00050A 56               [ 7] 1244 	ld	d, (hl)
      00050B FD 21r88r06      [14] 1245 	ld	iy, #_UnrolledRowWrites
      00050F FD 19            [15] 1246 	add	iy, de
                                   1247 ;	== Add Offset to Start location in Buffer.
      000511 3Ar1Br00         [13] 1248 	ld	a, (# #_GSL_RAM + 27)
      000514 0F               [ 4] 1249 	rrca
      000515 0F               [ 4] 1250 	rrca
      000516 E6 02            [ 7] 1251 	and	#2
      000518 C6 02            [ 7] 1252 	add	a, #2
      00051A 21r6Fr00         [10] 1253 	ld	hl, # #_GSL_RAM + 111
      00051D 5F               [ 4] 1254 	ld	e, a
      00051E AF               [ 4] 1255 	xor	a
      00051F 57               [ 4] 1256 	ld	d, a
      000520 19               [11] 1257 	add	hl, de
      000521 CDr05r06         [17] 1258 	call	IYJump
                                   1259 ;	== Update VDP Pointer For Second Write
                                   1260 ;	Second write always starts at left most side of Nametable so clear
                                   1261 ;	low bytes of address and update.
      000524 D9               [ 4] 1262 	exx
      000525 3E C0            [ 7] 1263 	ld	a, #192 ; %11000000
      000527 A5               [ 4] 1264 	and	l
      000528 ED 79            [12] 1265 	out	(c), a
      00052A ED 61            [12] 1266 	out	(c), h
      00052C D9               [ 4] 1267 	exx
                                   1268 ;	== Move Forward 130 bytes in LUT
      00052D EB               [ 4] 1269 	ex	de, hl
      00052E E1               [10] 1270 	pop	hl
      00052F 3E 40            [ 7] 1271 	ld	a, #64
      000531 85               [ 4] 1272 	add	a, l
      000532 6F               [ 4] 1273 	ld	l, a
      000533 D2r37r05         [10] 1274 	jp	nc, _rowExtractJumpAddress
      000536 24               [ 4] 1275 	inc	h
      000537                       1276 	_rowExtractJumpAddress:
                                   1277 ; == Extract Jump Location from LUT and store in IY
                                   1278 ;	Jump is for unrolled VDP Write code
      000537 4E               [ 7] 1279 	ld	c, (hl)
      000538 23               [ 6] 1280 	inc	hl
      000539 46               [ 7] 1281 	ld	b, (hl)
      00053A FD 21r88r06      [14] 1282 	ld	iy, #_UnrolledRowWrites
      00053E FD 09            [15] 1283 	add	iy, bc
      000540 EB               [ 4] 1284 	ex	de, hl
      000541 0E BE            [ 7] 1285 	ld	c, #0xBE
      000543 CDr05r06         [17] 1286 	call	IYJump
      000546                       1287 	_updateColumn:
                                   1288 ; == Check if row update required.
      000546 3Ar23r00         [13] 1289 	ld	a, (# #_GSL_RAM + 35)
      000549 A7               [ 4] 1290 	and	a
      00054A CArA7r05         [10] 1291 	jp	z, _MetatileUpdates
                                   1292 ;	== Put VDP Pointer Address in Shadow Register and Set VDP Pointer.
      00054D D9               [ 4] 1293 	exx
      00054E 2Ar25r00         [16] 1294 	ld	hl, (# #_GSL_RAM + 37)
      000551 11 40 00         [10] 1295 	ld	de, #64 ; Each new column entry is 64 bytes ahead, store here for addition
      000554 0E BF            [ 7] 1296 	ld	c, #0xBF
      000556 D9               [ 4] 1297 	exx
      000557 0E BE            [ 7] 1298 	ld	c, #0xBE
                                   1299 ;	== Construct LUT address For First Write
      000559 3Ar1Fr00         [13] 1300 	ld	a, (# #_GSL_RAM + 31)
      00055C E6 F8            [ 7] 1301 	and	#248 ; %11111000
      00055E 0F               [ 4] 1302 	rrca
      00055F 0F               [ 4] 1303 	rrca
      000560 21rBFr07         [10] 1304 	ld	hl, #_GSL_LUTColumnUpdate
      000563 85               [ 4] 1305 	add	a, l
      000564 D2r68r05         [10] 1306 	jp	nc, _finaliseLUTColumnAddress
      000567 24               [ 4] 1307 	inc	h
      000568                       1308 	_finaliseLUTColumnAddress:
      000568 6F               [ 4] 1309 	ld l, a
      000569 E5               [11] 1310 	push	hl ; Story copy on stack
                                   1311 ;	== Extract Jump Location from LUT and store in IY
                                   1312 ;	Jump is for unrolled VDP Write code
      00056A 5E               [ 7] 1313 	ld	e, (hl)
      00056B 23               [ 6] 1314 	inc	hl
      00056C 56               [ 7] 1315 	ld	d, (hl)
      00056D FD 21rBDr07      [14] 1316 	ld	iy, #_UnrolledColumnWrites
      000571 FD 19            [15] 1317 	add	iy, de
                                   1318 ;	== Add Offset to Start location in Buffer.
      000573 3Ar1Dr00         [13] 1319 	ld	a, (# #_GSL_RAM + 29)
      000576 E6 08            [ 7] 1320 	and	#8 ; %00001000
      000578 0F               [ 4] 1321 	rrca
      000579 0F               [ 4] 1322 	rrca
      00057A 21r2Fr00         [10] 1323 	ld	hl, # #_GSL_RAM + 47
      00057D 5F               [ 4] 1324 	ld	e, a
      00057E AF               [ 4] 1325 	xor	a
      00057F 57               [ 4] 1326 	ld	d, a
      000580 19               [11] 1327 	add	hl, de
      000581 CDr05r06         [17] 1328 	call	IYJump
                                   1329 ;	== Update VDP Pointer For Second Write
                                   1330 ;	Second write always starts at top row of Nametable so reset high byte
                                   1331 ;	to 0x78, keep low bytes of address and update.
      000584 D9               [ 4] 1332 	exx
      000585 3Ar25r00         [13] 1333 	ld	a, (# #_GSL_RAM + 37) ; Get vram nametable pointer
      000588 E6 3F            [ 7] 1334 	and	#63 ; %00111111
      00058A 26 78            [ 7] 1335 	ld	h, #0x78
      00058C 6F               [ 4] 1336 	ld	l, a
      00058D D9               [ 4] 1337 	exx
                                   1338 ;	== Move Forward 114 bytes in LUT
      00058E EB               [ 4] 1339 	ex	de, hl
      00058F E1               [10] 1340 	pop	hl
      000590 3E 38            [ 7] 1341 	ld	a, #56
      000592 85               [ 4] 1342 	add	a, l
      000593 6F               [ 4] 1343 	ld	l, a
      000594 D2r98r05         [10] 1344 	jp	nc, _columnExtractJumpAddress
      000597 24               [ 4] 1345 	inc	h
      000598                       1346 	_columnExtractJumpAddress:
                                   1347 ; == Extract Jump Location from LUT and store in IY
                                   1348 ;	Jump is for unrolled VDP Write code
      000598 4E               [ 7] 1349 	ld	c, (hl)
      000599 23               [ 6] 1350 	inc	hl
      00059A 46               [ 7] 1351 	ld	b, (hl)
      00059B FD 21rBDr07      [14] 1352 	ld	iy, #_UnrolledColumnWrites
      00059F FD 09            [15] 1353 	add	iy, bc
      0005A1 EB               [ 4] 1354 	ex	de, hl
      0005A2 0E BE            [ 7] 1355 	ld	c, #0xBE
      0005A4 CDr05r06         [17] 1356 	call	IYJump
      0005A7                       1357 	_MetatileUpdates:
                                   1358 ; == Check if Metatile Updates are Required.
      0005A7 3Ar29r00         [13] 1359 	ld	a, (# #_GSL_RAM + 41)
      0005AA B7               [ 4] 1360 	or	a
      0005AB CArE0r05         [10] 1361 	jp	z, _VBlankCleanup
      0005AE 21rB7r00         [10] 1362 	ld	hl, # #_GSL_RAM + 183
      0005B1 47               [ 4] 1363 	ld	b, a
      0005B2                       1364 	_MetatileUpdatesLoop:
                                   1365 ; == Process each metatile Update
      0005B2 3E 07            [ 7] 1366 	ld	a, #7 ; count = number of metatile to update.
      0005B4 80               [ 4] 1367 	add	a, b ; add 7 to current number, outi will reduce this by 8
      0005B5 47               [ 4] 1368 	ld	b, a ; end result will be to subtract 1 from current number
                                   1369 ;	== First word is VDP address of update. Update VDP Pointer.
      0005B6 56               [ 7] 1370 	ld	d, (hl)
      0005B7 23               [ 6] 1371 	inc	hl
      0005B8 5E               [ 7] 1372 	ld	e, (hl)
      0005B9 23               [ 6] 1373 	inc	hl
      0005BA 0E BF            [ 7] 1374 	ld	c, #0xBF
      0005BC ED 51            [12] 1375 	out	(c), d
      0005BE ED 59            [12] 1376 	out	(c), e
                                   1377 ;	== Write first two entries of Metatile.
      0005C0 0D               [ 4] 1378 	dec	c
      0005C1 ED A3            [16] 1379 	outi
      0005C3 ED A3            [16] 1380 	outi
      0005C5 ED A3            [16] 1381 	outi
      0005C7 ED A3            [16] 1382 	outi
                                   1383 ;	== Update VDP pointer to be one nametable row lower.
      0005C9 3E 40            [ 7] 1384 	ld	a, #64 ; $40
      0005CB 82               [ 4] 1385 	add	a, d
      0005CC 57               [ 4] 1386 	ld	d, a
      0005CD 0C               [ 4] 1387 	inc	c
      0005CE ED 51            [12] 1388 	out	(c), d
      0005D0 ED 59            [12] 1389 	out	(c), e
                                   1390 ;	== Write last two entries.
      0005D2 0D               [ 4] 1391 	dec	c
      0005D3 ED A3            [16] 1392 	outi
      0005D5 ED A3            [16] 1393 	outi
      0005D7 ED A3            [16] 1394 	outi
      0005D9 ED A3            [16] 1395 	outi
                                   1396 ;	== Loop if required.
      0005DB 78               [ 4] 1397 	ld	a, b
      0005DC B7               [ 4] 1398 	or	a
      0005DD C2rB2r05         [10] 1399 	jp	nz, _MetatileUpdatesLoop
      0005E0                       1400 	_VBlankCleanup:
                                   1401 ; == Reset RAM Variables for next Active Display.
      0005E0 21rB7r00         [10] 1402 	ld	hl, # #_GSL_RAM + 183
      0005E3 22r2Ar00         [16] 1403 	ld	(# #_GSL_RAM + 42), hl
      0005E6 AF               [ 4] 1404 	xor	a
      0005E7 32r29r00         [13] 1405 	ld	(# #_GSL_RAM + 41), a
      0005EA 32r21r00         [13] 1406 	ld	(# #_GSL_RAM + 33), a
      0005ED 32r22r00         [13] 1407 	ld	(# #_GSL_RAM + 34), a
                                   1408 ;	== Update Screen X,Y Scroll
      0005F0 3Ar1Br00         [13] 1409 	ld	a, (# #_GSL_RAM + 27)
      0005F3 ED 44            [ 8] 1410 	neg
      0005F5 D3 BF            [11] 1411 	out	(#0xBF), a
      0005F7 3E 88            [ 7] 1412 	ld	a, #136 ; $88
      0005F9 D3 BF            [11] 1413 	out	(#0xBF), a
      0005FB 3Ar1Fr00         [13] 1414 	ld	a, (# #_GSL_RAM + 31)
      0005FE D3 BF            [11] 1415 	out	(#0xBF), a
      000600 3E 89            [ 7] 1416 	ld	a, #137 ; $89
      000602 D3 BF            [11] 1417 	out	(#0xBF), a
      000604 C9               [10] 1418 	ret
      000605                       1419 	IYJump:
      000605 FD E9            [ 8] 1420 	jp (iy)
      000607 C9               [10] 1421 	ret
      000608 ED A3            [16] 1422 	outi
      00060A ED A3            [16] 1423 	outi
      00060C ED A3            [16] 1424 	outi
      00060E ED A3            [16] 1425 	outi
      000610 ED A3            [16] 1426 	outi
      000612 ED A3            [16] 1427 	outi
      000614 ED A3            [16] 1428 	outi
      000616 ED A3            [16] 1429 	outi
      000618 ED A3            [16] 1430 	outi
      00061A ED A3            [16] 1431 	outi
      00061C ED A3            [16] 1432 	outi
      00061E ED A3            [16] 1433 	outi
      000620 ED A3            [16] 1434 	outi
      000622 ED A3            [16] 1435 	outi
      000624 ED A3            [16] 1436 	outi
      000626 ED A3            [16] 1437 	outi
      000628 ED A3            [16] 1438 	outi
      00062A ED A3            [16] 1439 	outi
      00062C ED A3            [16] 1440 	outi
      00062E ED A3            [16] 1441 	outi
      000630 ED A3            [16] 1442 	outi
      000632 ED A3            [16] 1443 	outi
      000634 ED A3            [16] 1444 	outi
      000636 ED A3            [16] 1445 	outi
      000638 ED A3            [16] 1446 	outi
      00063A ED A3            [16] 1447 	outi
      00063C ED A3            [16] 1448 	outi
      00063E ED A3            [16] 1449 	outi
      000640 ED A3            [16] 1450 	outi
      000642 ED A3            [16] 1451 	outi
      000644 ED A3            [16] 1452 	outi
      000646 ED A3            [16] 1453 	outi
      000648 ED A3            [16] 1454 	outi
      00064A ED A3            [16] 1455 	outi
      00064C ED A3            [16] 1456 	outi
      00064E ED A3            [16] 1457 	outi
      000650 ED A3            [16] 1458 	outi
      000652 ED A3            [16] 1459 	outi
      000654 ED A3            [16] 1460 	outi
      000656 ED A3            [16] 1461 	outi
      000658 ED A3            [16] 1462 	outi
      00065A ED A3            [16] 1463 	outi
      00065C ED A3            [16] 1464 	outi
      00065E ED A3            [16] 1465 	outi
      000660 ED A3            [16] 1466 	outi
      000662 ED A3            [16] 1467 	outi
      000664 ED A3            [16] 1468 	outi
      000666 ED A3            [16] 1469 	outi
      000668 ED A3            [16] 1470 	outi
      00066A ED A3            [16] 1471 	outi
      00066C ED A3            [16] 1472 	outi
      00066E ED A3            [16] 1473 	outi
      000670 ED A3            [16] 1474 	outi
      000672 ED A3            [16] 1475 	outi
      000674 ED A3            [16] 1476 	outi
      000676 ED A3            [16] 1477 	outi
      000678 ED A3            [16] 1478 	outi
      00067A ED A3            [16] 1479 	outi
      00067C ED A3            [16] 1480 	outi
      00067E ED A3            [16] 1481 	outi
      000680 ED A3            [16] 1482 	outi
      000682 ED A3            [16] 1483 	outi
      000684 ED A3            [16] 1484 	outi
      000686 ED A3            [16] 1485 	outi
      000688                       1486 	_UnrolledRowWrites:
      000688 C9               [10] 1487 	ret
      000689 D9               [ 4] 1488 	exx
      00068A ED 69            [12] 1489 	out	(c), l
      00068C ED 61            [12] 1490 	out	(c), h
      00068E 19               [11] 1491 	add	hl, de
      00068F D9               [ 4] 1492 	exx
      000690 ED A3            [16] 1493 	outi
      000692 ED A3            [16] 1494 	outi
      000694 D9               [ 4] 1495 	exx
      000695 ED 69            [12] 1496 	out	(c), l
      000697 ED 61            [12] 1497 	out	(c), h
      000699 19               [11] 1498 	add	hl, de
      00069A D9               [ 4] 1499 	exx
      00069B ED A3            [16] 1500 	outi
      00069D ED A3            [16] 1501 	outi
      00069F D9               [ 4] 1502 	exx
      0006A0 ED 69            [12] 1503 	out	(c), l
      0006A2 ED 61            [12] 1504 	out	(c), h
      0006A4 19               [11] 1505 	add	hl, de
      0006A5 D9               [ 4] 1506 	exx
      0006A6 ED A3            [16] 1507 	outi
      0006A8 ED A3            [16] 1508 	outi
      0006AA D9               [ 4] 1509 	exx
      0006AB ED 69            [12] 1510 	out	(c), l
      0006AD ED 61            [12] 1511 	out	(c), h
      0006AF 19               [11] 1512 	add	hl, de
      0006B0 D9               [ 4] 1513 	exx
      0006B1 ED A3            [16] 1514 	outi
      0006B3 ED A3            [16] 1515 	outi
      0006B5 D9               [ 4] 1516 	exx
      0006B6 ED 69            [12] 1517 	out	(c), l
      0006B8 ED 61            [12] 1518 	out	(c), h
      0006BA 19               [11] 1519 	add	hl, de
      0006BB D9               [ 4] 1520 	exx
      0006BC ED A3            [16] 1521 	outi
      0006BE ED A3            [16] 1522 	outi
      0006C0 D9               [ 4] 1523 	exx
      0006C1 ED 69            [12] 1524 	out	(c), l
      0006C3 ED 61            [12] 1525 	out	(c), h
      0006C5 19               [11] 1526 	add	hl, de
      0006C6 D9               [ 4] 1527 	exx
      0006C7 ED A3            [16] 1528 	outi
      0006C9 ED A3            [16] 1529 	outi
      0006CB D9               [ 4] 1530 	exx
      0006CC ED 69            [12] 1531 	out	(c), l
      0006CE ED 61            [12] 1532 	out	(c), h
      0006D0 19               [11] 1533 	add	hl, de
      0006D1 D9               [ 4] 1534 	exx
      0006D2 ED A3            [16] 1535 	outi
      0006D4 ED A3            [16] 1536 	outi
      0006D6 D9               [ 4] 1537 	exx
      0006D7 ED 69            [12] 1538 	out	(c), l
      0006D9 ED 61            [12] 1539 	out	(c), h
      0006DB 19               [11] 1540 	add	hl, de
      0006DC D9               [ 4] 1541 	exx
      0006DD ED A3            [16] 1542 	outi
      0006DF ED A3            [16] 1543 	outi
      0006E1 D9               [ 4] 1544 	exx
      0006E2 ED 69            [12] 1545 	out	(c), l
      0006E4 ED 61            [12] 1546 	out	(c), h
      0006E6 19               [11] 1547 	add	hl, de
      0006E7 D9               [ 4] 1548 	exx
      0006E8 ED A3            [16] 1549 	outi
      0006EA ED A3            [16] 1550 	outi
      0006EC D9               [ 4] 1551 	exx
      0006ED ED 69            [12] 1552 	out	(c), l
      0006EF ED 61            [12] 1553 	out	(c), h
      0006F1 19               [11] 1554 	add	hl, de
      0006F2 D9               [ 4] 1555 	exx
      0006F3 ED A3            [16] 1556 	outi
      0006F5 ED A3            [16] 1557 	outi
      0006F7 D9               [ 4] 1558 	exx
      0006F8 ED 69            [12] 1559 	out	(c), l
      0006FA ED 61            [12] 1560 	out	(c), h
      0006FC 19               [11] 1561 	add	hl, de
      0006FD D9               [ 4] 1562 	exx
      0006FE ED A3            [16] 1563 	outi
      000700 ED A3            [16] 1564 	outi
      000702 D9               [ 4] 1565 	exx
      000703 ED 69            [12] 1566 	out	(c), l
      000705 ED 61            [12] 1567 	out	(c), h
      000707 19               [11] 1568 	add	hl, de
      000708 D9               [ 4] 1569 	exx
      000709 ED A3            [16] 1570 	outi
      00070B ED A3            [16] 1571 	outi
      00070D D9               [ 4] 1572 	exx
      00070E ED 69            [12] 1573 	out	(c), l
      000710 ED 61            [12] 1574 	out	(c), h
      000712 19               [11] 1575 	add	hl, de
      000713 D9               [ 4] 1576 	exx
      000714 ED A3            [16] 1577 	outi
      000716 ED A3            [16] 1578 	outi
      000718 D9               [ 4] 1579 	exx
      000719 ED 69            [12] 1580 	out	(c), l
      00071B ED 61            [12] 1581 	out	(c), h
      00071D 19               [11] 1582 	add	hl, de
      00071E D9               [ 4] 1583 	exx
      00071F ED A3            [16] 1584 	outi
      000721 ED A3            [16] 1585 	outi
      000723 D9               [ 4] 1586 	exx
      000724 ED 69            [12] 1587 	out	(c), l
      000726 ED 61            [12] 1588 	out	(c), h
      000728 19               [11] 1589 	add	hl, de
      000729 D9               [ 4] 1590 	exx
      00072A ED A3            [16] 1591 	outi
      00072C ED A3            [16] 1592 	outi
      00072E D9               [ 4] 1593 	exx
      00072F ED 69            [12] 1594 	out	(c), l
      000731 ED 61            [12] 1595 	out	(c), h
      000733 19               [11] 1596 	add	hl, de
      000734 D9               [ 4] 1597 	exx
      000735 ED A3            [16] 1598 	outi
      000737 ED A3            [16] 1599 	outi
      000739 D9               [ 4] 1600 	exx
      00073A ED 69            [12] 1601 	out	(c), l
      00073C ED 61            [12] 1602 	out	(c), h
      00073E 19               [11] 1603 	add	hl, de
      00073F D9               [ 4] 1604 	exx
      000740 ED A3            [16] 1605 	outi
      000742 ED A3            [16] 1606 	outi
      000744 D9               [ 4] 1607 	exx
      000745 ED 69            [12] 1608 	out	(c), l
      000747 ED 61            [12] 1609 	out	(c), h
      000749 19               [11] 1610 	add	hl, de
      00074A D9               [ 4] 1611 	exx
      00074B ED A3            [16] 1612 	outi
      00074D ED A3            [16] 1613 	outi
      00074F D9               [ 4] 1614 	exx
      000750 ED 69            [12] 1615 	out	(c), l
      000752 ED 61            [12] 1616 	out	(c), h
      000754 19               [11] 1617 	add	hl, de
      000755 D9               [ 4] 1618 	exx
      000756 ED A3            [16] 1619 	outi
      000758 ED A3            [16] 1620 	outi
      00075A D9               [ 4] 1621 	exx
      00075B ED 69            [12] 1622 	out	(c), l
      00075D ED 61            [12] 1623 	out	(c), h
      00075F 19               [11] 1624 	add	hl, de
      000760 D9               [ 4] 1625 	exx
      000761 ED A3            [16] 1626 	outi
      000763 ED A3            [16] 1627 	outi
      000765 D9               [ 4] 1628 	exx
      000766 ED 69            [12] 1629 	out	(c), l
      000768 ED 61            [12] 1630 	out	(c), h
      00076A 19               [11] 1631 	add	hl, de
      00076B D9               [ 4] 1632 	exx
      00076C ED A3            [16] 1633 	outi
      00076E ED A3            [16] 1634 	outi
      000770 D9               [ 4] 1635 	exx
      000771 ED 69            [12] 1636 	out	(c), l
      000773 ED 61            [12] 1637 	out	(c), h
      000775 19               [11] 1638 	add	hl, de
      000776 D9               [ 4] 1639 	exx
      000777 ED A3            [16] 1640 	outi
      000779 ED A3            [16] 1641 	outi
      00077B D9               [ 4] 1642 	exx
      00077C ED 69            [12] 1643 	out	(c), l
      00077E ED 61            [12] 1644 	out	(c), h
      000780 19               [11] 1645 	add	hl, de
      000781 D9               [ 4] 1646 	exx
      000782 ED A3            [16] 1647 	outi
      000784 ED A3            [16] 1648 	outi
      000786 D9               [ 4] 1649 	exx
      000787 ED 69            [12] 1650 	out	(c), l
      000789 ED 61            [12] 1651 	out	(c), h
      00078B 19               [11] 1652 	add	hl, de
      00078C D9               [ 4] 1653 	exx
      00078D ED A3            [16] 1654 	outi
      00078F ED A3            [16] 1655 	outi
      000791 D9               [ 4] 1656 	exx
      000792 ED 69            [12] 1657 	out	(c), l
      000794 ED 61            [12] 1658 	out	(c), h
      000796 19               [11] 1659 	add	hl, de
      000797 D9               [ 4] 1660 	exx
      000798 ED A3            [16] 1661 	outi
      00079A ED A3            [16] 1662 	outi
      00079C D9               [ 4] 1663 	exx
      00079D ED 69            [12] 1664 	out	(c), l
      00079F ED 61            [12] 1665 	out	(c), h
      0007A1 19               [11] 1666 	add	hl, de
      0007A2 D9               [ 4] 1667 	exx
      0007A3 ED A3            [16] 1668 	outi
      0007A5 ED A3            [16] 1669 	outi
      0007A7 D9               [ 4] 1670 	exx
      0007A8 ED 69            [12] 1671 	out	(c), l
      0007AA ED 61            [12] 1672 	out	(c), h
      0007AC 19               [11] 1673 	add	hl, de
      0007AD D9               [ 4] 1674 	exx
      0007AE ED A3            [16] 1675 	outi
      0007B0 ED A3            [16] 1676 	outi
      0007B2 D9               [ 4] 1677 	exx
      0007B3 ED 69            [12] 1678 	out	(c), l
      0007B5 ED 61            [12] 1679 	out	(c), h
      0007B7 19               [11] 1680 	add	hl, de
      0007B8 D9               [ 4] 1681 	exx
      0007B9 ED A3            [16] 1682 	outi
      0007BB ED A3            [16] 1683 	outi
      0007BD                       1684 	_UnrolledColumnWrites:
      0007BD C9               [10] 1685 	ret
      0007BE                       1686 	_Finalise:
                           0007BE  1687 	C$GSLib.c$1725$1_0$30	= .
                                   1688 	.globl	C$GSLib.c$1725$1_0$30
                                   1689 ;GSLib.c:1725: }
                           0007BE  1690 	C$GSLib.c$1725$1_0$30	= .
                                   1691 	.globl	C$GSLib.c$1725$1_0$30
                           0007BE  1692 	XG$GSL_initializeMap$0$0	= .
                                   1693 	.globl	XG$GSL_initializeMap$0$0
      0007BE C9               [10] 1694 	ret
                                   1695 	.area _CODE
                           0007BF  1696 G$GSL_LUTColumnUpdate$0_0$0 == .
      0007BF                       1697 _GSL_LUTColumnUpdate:
      0007BF CC FE                 1698 	.dw #0xfecc
      0007C1 D7 FE                 1699 	.dw #0xfed7
      0007C3 E2 FE                 1700 	.dw #0xfee2
      0007C5 ED FE                 1701 	.dw #0xfeed
      0007C7 F8 FE                 1702 	.dw #0xfef8
      0007C9 03 FF                 1703 	.dw #0xff03
      0007CB 0E FF                 1704 	.dw #0xff0e
      0007CD 19 FF                 1705 	.dw #0xff19
      0007CF 24 FF                 1706 	.dw #0xff24
      0007D1 2F FF                 1707 	.dw #0xff2f
      0007D3 3A FF                 1708 	.dw #0xff3a
      0007D5 45 FF                 1709 	.dw #0xff45
      0007D7 50 FF                 1710 	.dw #0xff50
      0007D9 5B FF                 1711 	.dw #0xff5b
      0007DB 66 FF                 1712 	.dw #0xff66
      0007DD 71 FF                 1713 	.dw #0xff71
      0007DF 7C FF                 1714 	.dw #0xff7c
      0007E1 87 FF                 1715 	.dw #0xff87
      0007E3 92 FF                 1716 	.dw #0xff92
      0007E5 9D FF                 1717 	.dw #0xff9d
      0007E7 A8 FF                 1718 	.dw #0xffa8
      0007E9 B3 FF                 1719 	.dw #0xffb3
      0007EB BE FF                 1720 	.dw #0xffbe
      0007ED C9 FF                 1721 	.dw #0xffc9
      0007EF D4 FF                 1722 	.dw #0xffd4
      0007F1 DF FF                 1723 	.dw #0xffdf
      0007F3 EA FF                 1724 	.dw #0xffea
      0007F5 F5 FF                 1725 	.dw #0xfff5
      0007F7 00 00                 1726 	.dw #0x0000
      0007F9 F5 FF                 1727 	.dw #0xfff5
      0007FB EA FF                 1728 	.dw #0xffea
      0007FD DF FF                 1729 	.dw #0xffdf
      0007FF D4 FF                 1730 	.dw #0xffd4
      000801 C9 FF                 1731 	.dw #0xffc9
      000803 BE FF                 1732 	.dw #0xffbe
      000805 B3 FF                 1733 	.dw #0xffb3
      000807 A8 FF                 1734 	.dw #0xffa8
      000809 9D FF                 1735 	.dw #0xff9d
      00080B 92 FF                 1736 	.dw #0xff92
      00080D 87 FF                 1737 	.dw #0xff87
      00080F 7C FF                 1738 	.dw #0xff7c
      000811 71 FF                 1739 	.dw #0xff71
      000813 66 FF                 1740 	.dw #0xff66
      000815 5B FF                 1741 	.dw #0xff5b
      000817 50 FF                 1742 	.dw #0xff50
      000819 45 FF                 1743 	.dw #0xff45
      00081B 3A FF                 1744 	.dw #0xff3a
      00081D 2F FF                 1745 	.dw #0xff2f
      00081F 24 FF                 1746 	.dw #0xff24
      000821 19 FF                 1747 	.dw #0xff19
      000823 0E FF                 1748 	.dw #0xff0e
      000825 03 FF                 1749 	.dw #0xff03
      000827 F8 FE                 1750 	.dw #0xfef8
      000829 ED FE                 1751 	.dw #0xfeed
      00082B E2 FE                 1752 	.dw #0xfee2
      00082D D7 FE                 1753 	.dw #0xfed7
                           00082F  1754 G$GSL_LUTRowUpdate$0_0$0 == .
      00082F                       1755 _GSL_LUTRowUpdate:
      00082F 84 FF                 1756 	.dw #0xff84
      000831 88 FF                 1757 	.dw #0xff88
      000833 8C FF                 1758 	.dw #0xff8c
      000835 90 FF                 1759 	.dw #0xff90
      000837 94 FF                 1760 	.dw #0xff94
      000839 98 FF                 1761 	.dw #0xff98
      00083B 9C FF                 1762 	.dw #0xff9c
      00083D A0 FF                 1763 	.dw #0xffa0
      00083F A4 FF                 1764 	.dw #0xffa4
      000841 A8 FF                 1765 	.dw #0xffa8
      000843 AC FF                 1766 	.dw #0xffac
      000845 B0 FF                 1767 	.dw #0xffb0
      000847 B4 FF                 1768 	.dw #0xffb4
      000849 B8 FF                 1769 	.dw #0xffb8
      00084B BC FF                 1770 	.dw #0xffbc
      00084D C0 FF                 1771 	.dw #0xffc0
      00084F C4 FF                 1772 	.dw #0xffc4
      000851 C8 FF                 1773 	.dw #0xffc8
      000853 CC FF                 1774 	.dw #0xffcc
      000855 D0 FF                 1775 	.dw #0xffd0
      000857 D4 FF                 1776 	.dw #0xffd4
      000859 D8 FF                 1777 	.dw #0xffd8
      00085B DC FF                 1778 	.dw #0xffdc
      00085D E0 FF                 1779 	.dw #0xffe0
      00085F E4 FF                 1780 	.dw #0xffe4
      000861 E8 FF                 1781 	.dw #0xffe8
      000863 EC FF                 1782 	.dw #0xffec
      000865 F0 FF                 1783 	.dw #0xfff0
      000867 F4 FF                 1784 	.dw #0xfff4
      000869 F8 FF                 1785 	.dw #0xfff8
      00086B FC FF                 1786 	.dw #0xfffc
      00086D 00 00                 1787 	.dw #0x0000
      00086F FC FF                 1788 	.dw #0xfffc
      000871 F8 FF                 1789 	.dw #0xfff8
      000873 F4 FF                 1790 	.dw #0xfff4
      000875 F0 FF                 1791 	.dw #0xfff0
      000877 EC FF                 1792 	.dw #0xffec
      000879 E8 FF                 1793 	.dw #0xffe8
      00087B E4 FF                 1794 	.dw #0xffe4
      00087D E0 FF                 1795 	.dw #0xffe0
      00087F DC FF                 1796 	.dw #0xffdc
      000881 D8 FF                 1797 	.dw #0xffd8
      000883 D4 FF                 1798 	.dw #0xffd4
      000885 D0 FF                 1799 	.dw #0xffd0
      000887 CC FF                 1800 	.dw #0xffcc
      000889 C8 FF                 1801 	.dw #0xffc8
      00088B C4 FF                 1802 	.dw #0xffc4
      00088D C0 FF                 1803 	.dw #0xffc0
      00088F BC FF                 1804 	.dw #0xffbc
      000891 B8 FF                 1805 	.dw #0xffb8
      000893 B4 FF                 1806 	.dw #0xffb4
      000895 B0 FF                 1807 	.dw #0xffb0
      000897 AC FF                 1808 	.dw #0xffac
      000899 A8 FF                 1809 	.dw #0xffa8
      00089B A4 FF                 1810 	.dw #0xffa4
      00089D A0 FF                 1811 	.dw #0xffa0
      00089F 9C FF                 1812 	.dw #0xff9c
      0008A1 98 FF                 1813 	.dw #0xff98
      0008A3 94 FF                 1814 	.dw #0xff94
      0008A5 90 FF                 1815 	.dw #0xff90
      0008A7 8C FF                 1816 	.dw #0xff8c
      0008A9 88 FF                 1817 	.dw #0xff88
      0008AB 84 FF                 1818 	.dw #0xff84
      0008AD 80 FF                 1819 	.dw #0xff80
                                   1820 	.area _INITIALIZER
                                   1821 	.area _CABS (ABS)
